{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83e\udd80\ud83d\udd25 IC Vibe Coding Bootcamp - Rust Beginner Edition Welcome to the IC Vibe Coding Bootcamp (Rust Beginner Edition) ! This bootcamp is designed to help you learn Rust programming language fundamentals and prepare you for Internet Computer Protocol (ICP) development. Whether you're completely new to Rust or looking to strengthen your foundational knowledge, this bootcamp will give you the skills you need to start building on the Internet Computer. \ud83d\udcdc Table of Contents \u2728 Bootcamp Structure \ud83d\ude80 Getting Started \ud83d\udcda Core Modules \ud83d\udce6 Optional Modules \ud83d\udd25 Final Challenge \ud83e\uddf0 Resources & Documentation \ud83d\udce9 Submit Your Project! \u2728 Bootcamp Structure This bootcamp is organized into Core Modules (essential for everyone) and Optional Modules (for those wanting to dive deeper). Each module contains learning materials and hands-on exercises to reinforce concepts. \ud83d\udcda Core Modules Module 1: Rust Fundamentals - Introduction to Rust, setup, and basic syntax Module 2: Memory Management - Ownership, borrowing, and Rust's memory model Module 3: Data Types - Structs, enums, and pattern matching Module 4: Code Organization - Packages, crates, and modules Module 5: Collections - Working with collections in Rust Module 7: ICP Integration - Internet Computer Protocol and Rust integration \ud83d\udce6 Optional Modules Module 6: Advanced Concepts - Traits, error handling, and testing \ud83d\udd25 Final Challenge After completing Module 5, you'll tackle a comprehensive challenge that combines concepts from all core modules. This practical project will solidify your understanding of Rust fundamentals. \ud83d\ude80 Getting Started Prerequisites Basic programming knowledge Curiosity and willingness to learn! A devcontainer is preconfigured for you to start coding instantly! Fork this repository. Click \"Code \u2192 Open with Codespaces\" Once the codespace is created, you can open it in VS Code Local Everything is pre-installed and ready for you to run the following commands Start Learning! Begin with Module 1: Rust Fundamentals and progress through the materials and exercises at your own pace. \ud83e\uddf0 Resources & Documentation The Rust Programming Language Book Rust By Example Rustlings Course Internet Computer Documentation Rust CDK Documentation \ud83d\udce9 Submit Your Project! \ud83c\udfaf Completed the final challenge? Submit your project here: \ud83d\udce2 Submission Form \ud83d\udccc Want to explore more challenges? Return to the index: \ud83d\udd17 ICP Bootcamp Index \ud83e\udd1d Contributing If you find any issues or have suggestions for improvement, please feel free to open an issue or submit a pull request. \ud83d\ude4f Credits This bootcamp was inspired by the excellent work from the elna-ai/bootcamp repository. We'd like to thank their creators for providing a great foundation that helped shape this learning resource. Ready to embark on your Rust journey? Let's get started! \ud83d\ude80\ud83e\udd80","title":"Home"},{"location":"#ic-vibe-coding-bootcamp-rust-beginner-edition","text":"Welcome to the IC Vibe Coding Bootcamp (Rust Beginner Edition) ! This bootcamp is designed to help you learn Rust programming language fundamentals and prepare you for Internet Computer Protocol (ICP) development. Whether you're completely new to Rust or looking to strengthen your foundational knowledge, this bootcamp will give you the skills you need to start building on the Internet Computer.","title":"\ud83e\udd80\ud83d\udd25 IC Vibe Coding Bootcamp - Rust Beginner Edition"},{"location":"#table-of-contents","text":"\u2728 Bootcamp Structure \ud83d\ude80 Getting Started \ud83d\udcda Core Modules \ud83d\udce6 Optional Modules \ud83d\udd25 Final Challenge \ud83e\uddf0 Resources & Documentation \ud83d\udce9 Submit Your Project!","title":"\ud83d\udcdc Table of Contents"},{"location":"#bootcamp-structure","text":"This bootcamp is organized into Core Modules (essential for everyone) and Optional Modules (for those wanting to dive deeper). Each module contains learning materials and hands-on exercises to reinforce concepts.","title":"\u2728 Bootcamp Structure"},{"location":"#core-modules","text":"Module 1: Rust Fundamentals - Introduction to Rust, setup, and basic syntax Module 2: Memory Management - Ownership, borrowing, and Rust's memory model Module 3: Data Types - Structs, enums, and pattern matching Module 4: Code Organization - Packages, crates, and modules Module 5: Collections - Working with collections in Rust Module 7: ICP Integration - Internet Computer Protocol and Rust integration","title":"\ud83d\udcda Core Modules"},{"location":"#optional-modules","text":"Module 6: Advanced Concepts - Traits, error handling, and testing","title":"\ud83d\udce6 Optional Modules"},{"location":"#final-challenge","text":"After completing Module 5, you'll tackle a comprehensive challenge that combines concepts from all core modules. This practical project will solidify your understanding of Rust fundamentals.","title":"\ud83d\udd25 Final Challenge"},{"location":"#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"#prerequisites","text":"Basic programming knowledge Curiosity and willingness to learn! A devcontainer is preconfigured for you to start coding instantly! Fork this repository. Click \"Code \u2192 Open with Codespaces\" Once the codespace is created, you can open it in VS Code Local Everything is pre-installed and ready for you to run the following commands","title":"Prerequisites"},{"location":"#start-learning","text":"Begin with Module 1: Rust Fundamentals and progress through the materials and exercises at your own pace.","title":"Start Learning!"},{"location":"#resources-documentation","text":"The Rust Programming Language Book Rust By Example Rustlings Course Internet Computer Documentation Rust CDK Documentation","title":"\ud83e\uddf0 Resources &amp; Documentation"},{"location":"#submit-your-project","text":"\ud83c\udfaf Completed the final challenge? Submit your project here: \ud83d\udce2 Submission Form \ud83d\udccc Want to explore more challenges? Return to the index: \ud83d\udd17 ICP Bootcamp Index","title":"\ud83d\udce9 Submit Your Project!"},{"location":"#contributing","text":"If you find any issues or have suggestions for improvement, please feel free to open an issue or submit a pull request.","title":"\ud83e\udd1d Contributing"},{"location":"#credits","text":"This bootcamp was inspired by the excellent work from the elna-ai/bootcamp repository. We'd like to thank their creators for providing a great foundation that helped shape this learning resource. Ready to embark on your Rust journey? Let's get started! \ud83d\ude80\ud83e\udd80","title":"\ud83d\ude4f Credits"},{"location":"module1-fundamentals/","text":"Module 1: Rust Fundamentals Core Module Learning Objectives Understand what Rust is and its key benefits Set up a local Rust development environment Learn basic Rust syntax and programming concepts Write and run simple Rust programs Content Summary This module introduces you to the Rust programming language, guides you through environment setup, and teaches the basic programming concepts in Rust including variables, data types, functions, and control flow. Topics Covered Introduction to Rust What is Rust? Benefits of Rust The Rust ecosystem Getting Started Setting up Rust (rustup, cargo) Using the Rust Playground Hello World program Understanding Rust compilation Basic Programming Concepts Variables and mutability Basic data types (integers, floating-point, booleans, characters, etc.) Functions Comments Control flow (if/else, loops) Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Hello, Rust! - Write a program that prints a personalized greeting Variable Basics - Practice declaring and using variables of different types Function Workshop - Create and use functions with various parameters and return types Control Flow Challenge - Solve problems using conditionals and loops Resources The Rust Programming Language Book - Chapters 1-3 Rust By Example - Chapters 1-5 Rustlings Course - First Steps and Basic Concepts","title":"Overview"},{"location":"module1-fundamentals/#module-1-rust-fundamentals","text":"","title":"Module 1: Rust Fundamentals"},{"location":"module1-fundamentals/#core-module","text":"","title":"Core Module"},{"location":"module1-fundamentals/#learning-objectives","text":"Understand what Rust is and its key benefits Set up a local Rust development environment Learn basic Rust syntax and programming concepts Write and run simple Rust programs","title":"Learning Objectives"},{"location":"module1-fundamentals/#content-summary","text":"This module introduces you to the Rust programming language, guides you through environment setup, and teaches the basic programming concepts in Rust including variables, data types, functions, and control flow.","title":"Content Summary"},{"location":"module1-fundamentals/#topics-covered","text":"Introduction to Rust What is Rust? Benefits of Rust The Rust ecosystem Getting Started Setting up Rust (rustup, cargo) Using the Rust Playground Hello World program Understanding Rust compilation Basic Programming Concepts Variables and mutability Basic data types (integers, floating-point, booleans, characters, etc.) Functions Comments Control flow (if/else, loops)","title":"Topics Covered"},{"location":"module1-fundamentals/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Hello, Rust! - Write a program that prints a personalized greeting Variable Basics - Practice declaring and using variables of different types Function Workshop - Create and use functions with various parameters and return types Control Flow Challenge - Solve problems using conditionals and loops","title":"Exercises"},{"location":"module1-fundamentals/#resources","text":"The Rust Programming Language Book - Chapters 1-3 Rust By Example - Chapters 1-5 Rustlings Course - First Steps and Basic Concepts","title":"Resources"},{"location":"module1-fundamentals/exercises/01_hello_rust/","text":"Exercise 1: Hello, Rust! Problem Statement Write a Rust program that: Asks the user for their name Prints a personalized greeting including their name Prints the current date Learning Objectives Practice using the println! macro Learn how to get user input using std::io Format strings using Rust's formatting capabilities Starter Code use std::io; fn main() { // TODO: 1. Prompt the user for their name // TODO: 2. Read the user's input let mut name = String::new(); // TODO: 3. Print a personalized greeting // BONUS: Print the current date // Hint: You can use the chrono crate for this } How to Run Your Code First, modify the starter code in 01_hello_rust_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_01 Expected Output What is your name? Alice Hello, Alice! Welcome to the Rust Bootcamp! Today is [current date]. Tips Use io::stdin().read_line(&mut name) to read user input Remember to handle the Result returned by read_line To trim whitespace (like newlines) from the input, use name.trim() For the bonus, you'll need to add the chrono crate to your dependencies in Cargo.toml","title":"Hello Rust"},{"location":"module1-fundamentals/exercises/01_hello_rust/#exercise-1-hello-rust","text":"","title":"Exercise 1: Hello, Rust!"},{"location":"module1-fundamentals/exercises/01_hello_rust/#problem-statement","text":"Write a Rust program that: Asks the user for their name Prints a personalized greeting including their name Prints the current date","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/01_hello_rust/#learning-objectives","text":"Practice using the println! macro Learn how to get user input using std::io Format strings using Rust's formatting capabilities","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/01_hello_rust/#starter-code","text":"use std::io; fn main() { // TODO: 1. Prompt the user for their name // TODO: 2. Read the user's input let mut name = String::new(); // TODO: 3. Print a personalized greeting // BONUS: Print the current date // Hint: You can use the chrono crate for this }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/01_hello_rust/#how-to-run-your-code","text":"First, modify the starter code in 01_hello_rust_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_01","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/01_hello_rust/#expected-output","text":"What is your name? Alice Hello, Alice! Welcome to the Rust Bootcamp! Today is [current date].","title":"Expected Output"},{"location":"module1-fundamentals/exercises/01_hello_rust/#tips","text":"Use io::stdin().read_line(&mut name) to read user input Remember to handle the Result returned by read_line To trim whitespace (like newlines) from the input, use name.trim() For the bonus, you'll need to add the chrono crate to your dependencies in Cargo.toml","title":"Tips"},{"location":"module1-fundamentals/exercises/02_variable_basics/","text":"Exercise 2: Variable Basics Problem Statement Write a Rust program that: Declares variables of different types (integer, float, boolean, and character) Demonstrates mutability by modifying some variables Uses type annotations and type inference Performs basic arithmetic operations between variables Displays the values and results using println! Learning Objectives Practice declaring variables in Rust Understand Rust's type system and how to annotate types Learn about mutability and the difference between let and let mut Get comfortable with basic operations on different data types Starter Code fn main() { // TODO: 1. Declare an immutable integer variable // TODO: 2. Declare a mutable float variable and modify it later // TODO: 3. Declare a boolean variable using type inference // TODO: 4. Declare a character variable with explicit type annotation // TODO: 5. Perform arithmetic operations with the numeric variables // TODO: 6. Print all variables and calculation results with appropriate labels } How to Run Your Code First, modify the starter code in 02_variable_basics_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_02 Expected Output Your output should show the values of all your variables and calculation results with clear labels, like: Integer value: 42 Original float value: 3.14 Modified float value: 6.28 Boolean value: true Character value: R Addition result: 45.14 Multiplication result: 131.88 Tips Remember that by default, variables in Rust are immutable To make a variable mutable, use the let mut syntax You can explicitly specify types using the syntax: let variable_name: type = value; Or let Rust infer the type: let variable_name = value; Use proper formatting with println! to make your output readable","title":"Variable Basics"},{"location":"module1-fundamentals/exercises/02_variable_basics/#exercise-2-variable-basics","text":"","title":"Exercise 2: Variable Basics"},{"location":"module1-fundamentals/exercises/02_variable_basics/#problem-statement","text":"Write a Rust program that: Declares variables of different types (integer, float, boolean, and character) Demonstrates mutability by modifying some variables Uses type annotations and type inference Performs basic arithmetic operations between variables Displays the values and results using println!","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/02_variable_basics/#learning-objectives","text":"Practice declaring variables in Rust Understand Rust's type system and how to annotate types Learn about mutability and the difference between let and let mut Get comfortable with basic operations on different data types","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/02_variable_basics/#starter-code","text":"fn main() { // TODO: 1. Declare an immutable integer variable // TODO: 2. Declare a mutable float variable and modify it later // TODO: 3. Declare a boolean variable using type inference // TODO: 4. Declare a character variable with explicit type annotation // TODO: 5. Perform arithmetic operations with the numeric variables // TODO: 6. Print all variables and calculation results with appropriate labels }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/02_variable_basics/#how-to-run-your-code","text":"First, modify the starter code in 02_variable_basics_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_02","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/02_variable_basics/#expected-output","text":"Your output should show the values of all your variables and calculation results with clear labels, like: Integer value: 42 Original float value: 3.14 Modified float value: 6.28 Boolean value: true Character value: R Addition result: 45.14 Multiplication result: 131.88","title":"Expected Output"},{"location":"module1-fundamentals/exercises/02_variable_basics/#tips","text":"Remember that by default, variables in Rust are immutable To make a variable mutable, use the let mut syntax You can explicitly specify types using the syntax: let variable_name: type = value; Or let Rust infer the type: let variable_name = value; Use proper formatting with println! to make your output readable","title":"Tips"},{"location":"module1-fundamentals/exercises/03_function_workshop/","text":"Exercise 3: Function Workshop Problem Statement Write a Rust program that: Defines and calls a function that takes two integers and returns their sum Creates a function that calculates the area of a rectangle (width \u00d7 height) Implements a function that checks if a number is prime Writes a function that converts temperatures between Fahrenheit and Celsius Uses all these functions in the main function and displays the results Learning Objectives Practice defining and calling functions in Rust Learn about function parameters and return types Understand different ways to return values from functions Apply control flow within functions Starter Code // TODO: 1. Define a function that adds two integers and returns the result // TODO: 2. Define a function that calculates the area of a rectangle // TODO: 3. Define a function that checks if a number is prime // TODO: 4. Define a function that converts Fahrenheit to Celsius // Formula: C = (F - 32) * 5/9 fn main() { // TODO: Call the addition function with different values and print the results // TODO: Calculate and print the area of rectangles with different dimensions // TODO: Test your prime number checker with several numbers // TODO: Convert and print some temperatures from Fahrenheit to Celsius } How to Run Your Code First, modify the starter code in 03_function_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_03 Expected Output Your output should show the results of calling all your functions with different inputs: Sum of 10 and 25 is: 35 Area of rectangle with width 5 and height 10 is: 50 square units Is 7 a prime number? true Is 12 a prime number? false 98.6\u00b0F is equivalent to 37.0\u00b0C 32.0\u00b0F is equivalent to 0.0\u00b0C Tips Use explicit return type annotations: fn function_name(parameter: type) -> return_type The last expression in a function becomes the return value (no semicolon) You can also use the return keyword explicitly For the prime number checker, a number is prime if it's greater than 1 and only divisible by 1 and itself Use appropriate control flow (loops, conditionals) in your prime number function Format your outputs clearly using the println! macro","title":"Function Workshop"},{"location":"module1-fundamentals/exercises/03_function_workshop/#exercise-3-function-workshop","text":"","title":"Exercise 3: Function Workshop"},{"location":"module1-fundamentals/exercises/03_function_workshop/#problem-statement","text":"Write a Rust program that: Defines and calls a function that takes two integers and returns their sum Creates a function that calculates the area of a rectangle (width \u00d7 height) Implements a function that checks if a number is prime Writes a function that converts temperatures between Fahrenheit and Celsius Uses all these functions in the main function and displays the results","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/03_function_workshop/#learning-objectives","text":"Practice defining and calling functions in Rust Learn about function parameters and return types Understand different ways to return values from functions Apply control flow within functions","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/03_function_workshop/#starter-code","text":"// TODO: 1. Define a function that adds two integers and returns the result // TODO: 2. Define a function that calculates the area of a rectangle // TODO: 3. Define a function that checks if a number is prime // TODO: 4. Define a function that converts Fahrenheit to Celsius // Formula: C = (F - 32) * 5/9 fn main() { // TODO: Call the addition function with different values and print the results // TODO: Calculate and print the area of rectangles with different dimensions // TODO: Test your prime number checker with several numbers // TODO: Convert and print some temperatures from Fahrenheit to Celsius }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/03_function_workshop/#how-to-run-your-code","text":"First, modify the starter code in 03_function_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_03","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/03_function_workshop/#expected-output","text":"Your output should show the results of calling all your functions with different inputs: Sum of 10 and 25 is: 35 Area of rectangle with width 5 and height 10 is: 50 square units Is 7 a prime number? true Is 12 a prime number? false 98.6\u00b0F is equivalent to 37.0\u00b0C 32.0\u00b0F is equivalent to 0.0\u00b0C","title":"Expected Output"},{"location":"module1-fundamentals/exercises/03_function_workshop/#tips","text":"Use explicit return type annotations: fn function_name(parameter: type) -> return_type The last expression in a function becomes the return value (no semicolon) You can also use the return keyword explicitly For the prime number checker, a number is prime if it's greater than 1 and only divisible by 1 and itself Use appropriate control flow (loops, conditionals) in your prime number function Format your outputs clearly using the println! macro","title":"Tips"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/","text":"Exercise 4: Control Flow Challenge Problem Statement Write a Rust program that demonstrates control flow by implementing: A FizzBuzz program that prints numbers from 1 to N, but: For multiples of 3, print \"Fizz\" instead of the number For multiples of 5, print \"Buzz\" instead of the number For multiples of both 3 and 5, print \"FizzBuzz\" A menu-driven calculator that: Prompts the user to select an operation (add, subtract, multiply, divide) Asks for two numbers Performs the selected operation and displays the result Allows the user to perform multiple calculations until they choose to exit Learning Objectives Practice using if-else statements, match expressions, and loops Learn how to handle user input with control flow Implement common programming patterns using Rust's control flow constructs Understand how to create a menu-driven program with multiple options Starter Code use std::io; fn main() { // Part 1: FizzBuzz Implementation println!(\"=== FizzBuzz Challenge ===\"); // TODO: Implement the FizzBuzz algorithm for numbers 1 to 20 // Part 2: Menu-driven Calculator println!(\"\\n=== Calculator ===\"); // TODO: Implement a menu-driven calculator with a loop that: // 1. Shows operation options // 2. Gets the user's choice // 3. Gets two numbers from the user // 4. Performs the calculation and shows the result // 5. Asks if the user wants to perform another calculation } How to Run Your Code First, modify the starter code in 04_control_flow_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_04 Expected Output For the FizzBuzz portion: === FizzBuzz Challenge === 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ... For the calculator portion: === Calculator === Choose an operation: 1. Add 2. Subtract 3. Multiply 4. Divide 5. Exit Enter your choice: 1 Enter first number: 10 Enter second number: 5 Result: 10 + 5 = 15 Do you want to perform another calculation? (y/n): y ... Tips For FizzBuzz, consider using a for loop with range Check divisibility using the modulo operator % Use match expressions for the menu selection in the calculator part Remember to handle potential errors when parsing user input Consider using a loop like loop with a break condition for the calculator's main operation","title":"Control Flow Challenge"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#exercise-4-control-flow-challenge","text":"","title":"Exercise 4: Control Flow Challenge"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#problem-statement","text":"Write a Rust program that demonstrates control flow by implementing: A FizzBuzz program that prints numbers from 1 to N, but: For multiples of 3, print \"Fizz\" instead of the number For multiples of 5, print \"Buzz\" instead of the number For multiples of both 3 and 5, print \"FizzBuzz\" A menu-driven calculator that: Prompts the user to select an operation (add, subtract, multiply, divide) Asks for two numbers Performs the selected operation and displays the result Allows the user to perform multiple calculations until they choose to exit","title":"Problem Statement"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#learning-objectives","text":"Practice using if-else statements, match expressions, and loops Learn how to handle user input with control flow Implement common programming patterns using Rust's control flow constructs Understand how to create a menu-driven program with multiple options","title":"Learning Objectives"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#starter-code","text":"use std::io; fn main() { // Part 1: FizzBuzz Implementation println!(\"=== FizzBuzz Challenge ===\"); // TODO: Implement the FizzBuzz algorithm for numbers 1 to 20 // Part 2: Menu-driven Calculator println!(\"\\n=== Calculator ===\"); // TODO: Implement a menu-driven calculator with a loop that: // 1. Shows operation options // 2. Gets the user's choice // 3. Gets two numbers from the user // 4. Performs the calculation and shows the result // 5. Asks if the user wants to perform another calculation }","title":"Starter Code"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#how-to-run-your-code","text":"First, modify the starter code in 04_control_flow_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module1_04","title":"How to Run Your Code"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#expected-output","text":"For the FizzBuzz portion: === FizzBuzz Challenge === 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ... For the calculator portion: === Calculator === Choose an operation: 1. Add 2. Subtract 3. Multiply 4. Divide 5. Exit Enter your choice: 1 Enter first number: 10 Enter second number: 5 Result: 10 + 5 = 15 Do you want to perform another calculation? (y/n): y ...","title":"Expected Output"},{"location":"module1-fundamentals/exercises/04_control_flow_challenge/#tips","text":"For FizzBuzz, consider using a for loop with range Check divisibility using the modulo operator % Use match expressions for the menu selection in the calculator part Remember to handle potential errors when parsing user input Consider using a loop like loop with a break condition for the calculator's main operation","title":"Tips"},{"location":"module2-memory-management/","text":"Module 2: Memory Management Core Module Learning Objectives Understand Rust's ownership system and its rules Learn how to use references and borrowing Master Rust's approach to memory safety without garbage collection Work with different data types and understand their memory characteristics Content Summary This module covers Rust's unique approach to memory management through ownership, borrowing, and lifetimes. You'll learn how Rust ensures memory safety at compile time without needing a garbage collector. Topics Covered Memory Concepts Stack vs. Heap Memory allocation and deallocation Understanding memory safety challenges Ownership Ownership rules Move semantics Clone and Copy traits Borrowing References and borrowing Mutable and immutable references Reference rules and validations Slices String slices Array slices Using slices in functions Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Ownership Practice - Identify and fix ownership issues in code samples Borrowing Challenge - Refactor code to use references properly Slice Workshop - Work with various slice types to solve problems Memory Management Debugging - Find and fix memory-related bugs Resources The Rust Programming Language Book - Chapters 4 Rust By Example - Ownership and Borrowing Rustnomicon - Ownership","title":"Overview"},{"location":"module2-memory-management/#module-2-memory-management","text":"","title":"Module 2: Memory Management"},{"location":"module2-memory-management/#core-module","text":"","title":"Core Module"},{"location":"module2-memory-management/#learning-objectives","text":"Understand Rust's ownership system and its rules Learn how to use references and borrowing Master Rust's approach to memory safety without garbage collection Work with different data types and understand their memory characteristics","title":"Learning Objectives"},{"location":"module2-memory-management/#content-summary","text":"This module covers Rust's unique approach to memory management through ownership, borrowing, and lifetimes. You'll learn how Rust ensures memory safety at compile time without needing a garbage collector.","title":"Content Summary"},{"location":"module2-memory-management/#topics-covered","text":"Memory Concepts Stack vs. Heap Memory allocation and deallocation Understanding memory safety challenges Ownership Ownership rules Move semantics Clone and Copy traits Borrowing References and borrowing Mutable and immutable references Reference rules and validations Slices String slices Array slices Using slices in functions","title":"Topics Covered"},{"location":"module2-memory-management/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Ownership Practice - Identify and fix ownership issues in code samples Borrowing Challenge - Refactor code to use references properly Slice Workshop - Work with various slice types to solve problems Memory Management Debugging - Find and fix memory-related bugs","title":"Exercises"},{"location":"module2-memory-management/#resources","text":"The Rust Programming Language Book - Chapters 4 Rust By Example - Ownership and Borrowing Rustnomicon - Ownership","title":"Resources"},{"location":"module2-memory-management/exercises/01_ownership_practice/","text":"Exercise 1: Ownership Practice Problem Statement Identify and fix the ownership issues in the following code samples. The goal is to make all examples compile and run correctly without changing their intended functionality. Learning Objectives Identify common ownership problems Apply appropriate solutions (cloning, borrowing, etc.) Understand the implications of move semantics Starter Code // Example 1: String ownership fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error: s1 has been moved } // Example 2: Function ownership fn main() { let s = String::from(\"hello\"); takes_ownership(s); println!(\"After function call: {}\", s); // Error: s has been moved } fn takes_ownership(some_string: String) { println!(\"Inside function: {}\", some_string); } // Example 3: Vector ownership fn main() { let v = vec![1, 2, 3, 4, 5]; for i in v { println!(\"{}\", i); } // Calculate and print the sum of elements in v let sum: i32 = v.iter().sum(); // Error: v has been moved in the for loop println!(\"Sum: {}\", sum); } How to Run Your Code First, modify the starter code in 01_ownership_practice_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module2_01 Expected Output After fixing the ownership issues, your code should produce the following outputs: Example 1: hello, world! Example 2: Inside function: hello After function call: hello Example 3: 1 2 3 4 5 Sum: 15 Tips Consider when to use clone() to duplicate data Look for opportunities to use references ( & ) instead of moving values Remember that for loops take ownership of collections by default unless you iterate over references","title":"Ownership Practice"},{"location":"module2-memory-management/exercises/01_ownership_practice/#exercise-1-ownership-practice","text":"","title":"Exercise 1: Ownership Practice"},{"location":"module2-memory-management/exercises/01_ownership_practice/#problem-statement","text":"Identify and fix the ownership issues in the following code samples. The goal is to make all examples compile and run correctly without changing their intended functionality.","title":"Problem Statement"},{"location":"module2-memory-management/exercises/01_ownership_practice/#learning-objectives","text":"Identify common ownership problems Apply appropriate solutions (cloning, borrowing, etc.) Understand the implications of move semantics","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/01_ownership_practice/#starter-code","text":"// Example 1: String ownership fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error: s1 has been moved } // Example 2: Function ownership fn main() { let s = String::from(\"hello\"); takes_ownership(s); println!(\"After function call: {}\", s); // Error: s has been moved } fn takes_ownership(some_string: String) { println!(\"Inside function: {}\", some_string); } // Example 3: Vector ownership fn main() { let v = vec![1, 2, 3, 4, 5]; for i in v { println!(\"{}\", i); } // Calculate and print the sum of elements in v let sum: i32 = v.iter().sum(); // Error: v has been moved in the for loop println!(\"Sum: {}\", sum); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/01_ownership_practice/#how-to-run-your-code","text":"First, modify the starter code in 01_ownership_practice_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module2_01","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/01_ownership_practice/#expected-output","text":"After fixing the ownership issues, your code should produce the following outputs: Example 1: hello, world! Example 2: Inside function: hello After function call: hello Example 3: 1 2 3 4 5 Sum: 15","title":"Expected Output"},{"location":"module2-memory-management/exercises/01_ownership_practice/#tips","text":"Consider when to use clone() to duplicate data Look for opportunities to use references ( & ) instead of moving values Remember that for loops take ownership of collections by default unless you iterate over references","title":"Tips"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/","text":"Exercise 2: Borrowing Challenge Problem Statement Write a Rust program that demonstrates proper use of borrowing and references by: Creating a function that takes an immutable reference to a string and returns its length Creating a function that takes a mutable reference to a vector and adds elements to it Creating a function that processes multiple references to different data structures Fixing code that violates Rust's borrowing rules Learning Objectives Understand the difference between mutable and immutable references Learn how to use references to avoid unnecessary copying of data Practice working with Rust's borrowing rules Identify and fix common borrowing issues Starter Code // 1. Processing string data with immutable references fn get_length(/* TODO: Add parameter for an immutable reference to a String */) -> usize { // TODO: Return the length of the string 0 // Replace this placeholder } // 2. Modifying vector data with mutable references fn add_three_elements(/* TODO: Add parameter for a mutable reference to a Vec<i32> */) { // TODO: Add three elements (10, 20, and 30) to the vector } // 3. Processing multiple data structures fn calculate_stats(/* TODO: Add parameters for references to needed data structures */) -> (f64, i32) { // TODO: Calculate and return the average of the numbers vector and the count of items in the strings vector (0.0, 0) // Replace this placeholder } // 4. Borrowing rules demonstration fn fix_borrowing_issues() { let mut data = vec![1, 2, 3]; // TODO: The following code has borrowing issues. Uncomment and fix it. // let ref1 = &mut data; // let ref2 = &mut data; // ref1.push(4); // ref2.push(5); // println!(\"Modified data: {:?}\", data); // TODO: Fix another example of borrowing issue // let ref3 = &data; // let ref4 = &mut data; // println!(\"Data length: {}\", ref3.len()); // ref4.push(6); } fn main() { // 1. Test immutable reference function let test_string = String::from(\"Hello, Rust borrowing!\"); let length = get_length(/* TODO: Pass the string as an immutable reference */); println!(\"String length: {}\", length); // Verify the string is still usable after passing as reference println!(\"Original string: {}\", test_string); // 2. Test mutable reference function let mut my_vec = Vec::new(); println!(\"Before function call: {:?}\", my_vec); add_three_elements(/* TODO: Pass the vector as a mutable reference */); println!(\"After function call: {:?}\", my_vec); // 3. Test multiple references let numbers = vec![10.0, 20.0, 30.0, 40.0, 50.0]; let words = vec![String::from(\"apple\"), String::from(\"banana\"), String::from(\"cherry\")]; let (average, count) = calculate_stats(/* TODO: Pass appropriate references */); println!(\"Average of numbers: {:.1}, Count of strings: {}\", average, count); // 4. Test the fixed borrowing issues fix_borrowing_issues(); } How to Run Your Code First, modify the starter code in 02_borrowing_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_02 Expected Output String length: 22 Original string: Hello, Rust borrowing! Before function call: [] After function call: [10, 20, 30] Average of numbers: 30.0, Count of strings: 3 Modified data: [1, 2, 3, 4, 5] Data length: 5 Modified data: [1, 2, 3, 4, 5, 6] Tips Remember that Rust allows multiple immutable references OR one mutable reference at a time Use & for immutable references and &mut for mutable references Pass references to functions using &variable or &mut variable Think about the lifetime of references - they must not outlive the data they reference For the borrowing issues section, consider scope and non-overlapping use of references","title":"Borrowing Challenge"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#exercise-2-borrowing-challenge","text":"","title":"Exercise 2: Borrowing Challenge"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#problem-statement","text":"Write a Rust program that demonstrates proper use of borrowing and references by: Creating a function that takes an immutable reference to a string and returns its length Creating a function that takes a mutable reference to a vector and adds elements to it Creating a function that processes multiple references to different data structures Fixing code that violates Rust's borrowing rules","title":"Problem Statement"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#learning-objectives","text":"Understand the difference between mutable and immutable references Learn how to use references to avoid unnecessary copying of data Practice working with Rust's borrowing rules Identify and fix common borrowing issues","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#starter-code","text":"// 1. Processing string data with immutable references fn get_length(/* TODO: Add parameter for an immutable reference to a String */) -> usize { // TODO: Return the length of the string 0 // Replace this placeholder } // 2. Modifying vector data with mutable references fn add_three_elements(/* TODO: Add parameter for a mutable reference to a Vec<i32> */) { // TODO: Add three elements (10, 20, and 30) to the vector } // 3. Processing multiple data structures fn calculate_stats(/* TODO: Add parameters for references to needed data structures */) -> (f64, i32) { // TODO: Calculate and return the average of the numbers vector and the count of items in the strings vector (0.0, 0) // Replace this placeholder } // 4. Borrowing rules demonstration fn fix_borrowing_issues() { let mut data = vec![1, 2, 3]; // TODO: The following code has borrowing issues. Uncomment and fix it. // let ref1 = &mut data; // let ref2 = &mut data; // ref1.push(4); // ref2.push(5); // println!(\"Modified data: {:?}\", data); // TODO: Fix another example of borrowing issue // let ref3 = &data; // let ref4 = &mut data; // println!(\"Data length: {}\", ref3.len()); // ref4.push(6); } fn main() { // 1. Test immutable reference function let test_string = String::from(\"Hello, Rust borrowing!\"); let length = get_length(/* TODO: Pass the string as an immutable reference */); println!(\"String length: {}\", length); // Verify the string is still usable after passing as reference println!(\"Original string: {}\", test_string); // 2. Test mutable reference function let mut my_vec = Vec::new(); println!(\"Before function call: {:?}\", my_vec); add_three_elements(/* TODO: Pass the vector as a mutable reference */); println!(\"After function call: {:?}\", my_vec); // 3. Test multiple references let numbers = vec![10.0, 20.0, 30.0, 40.0, 50.0]; let words = vec![String::from(\"apple\"), String::from(\"banana\"), String::from(\"cherry\")]; let (average, count) = calculate_stats(/* TODO: Pass appropriate references */); println!(\"Average of numbers: {:.1}, Count of strings: {}\", average, count); // 4. Test the fixed borrowing issues fix_borrowing_issues(); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#how-to-run-your-code","text":"First, modify the starter code in 02_borrowing_challenge_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_02","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#expected-output","text":"String length: 22 Original string: Hello, Rust borrowing! Before function call: [] After function call: [10, 20, 30] Average of numbers: 30.0, Count of strings: 3 Modified data: [1, 2, 3, 4, 5] Data length: 5 Modified data: [1, 2, 3, 4, 5, 6]","title":"Expected Output"},{"location":"module2-memory-management/exercises/02_borrowing_challenge/#tips","text":"Remember that Rust allows multiple immutable references OR one mutable reference at a time Use & for immutable references and &mut for mutable references Pass references to functions using &variable or &mut variable Think about the lifetime of references - they must not outlive the data they reference For the borrowing issues section, consider scope and non-overlapping use of references","title":"Tips"},{"location":"module2-memory-management/exercises/03_slice_workshop/","text":"Exercise 3: Slice Workshop Problem Statement Write a Rust program that demonstrates effective use of slices by: Creating a function that takes a string slice and returns the first word Creating a function that takes an array slice and returns the sum of its elements Implementing a function that finds the middle element(s) of a slice Creating a function that extracts a specific part of a slice based on a condition Learning Objectives Understand what slices are and how they differ from full collections Learn to use string slices effectively Practice working with array and vector slices Understand the relationship between slices and references Starter Code // 1. Find the first word in a string fn first_word(s: /* TODO: Add parameter type for a string slice */) -> /* TODO: Return type */ { // TODO: Return the first word in the string (up to the first space or the entire string if no spaces) \"\" } // 2. Calculate the sum of elements in an array slice fn sum_slice(numbers: /* TODO: Add parameter type for a slice of integers */) -> i32 { // TODO: Calculate and return the sum of all elements in the slice 0 } // 3. Find the middle element(s) of a slice fn middle_elements(slice: /* TODO: Add parameter type for a generic slice */) -> /* TODO: Return type */ { // TODO: Return the middle element if length is odd, or the two middle elements if length is even // Hint: For a generic implementation, you'll need to handle both cases if slice.len() % 2 == 1 { // Odd length - return a slice containing just the middle element } else { // Even length - return a slice containing the two middle elements } &slice[0..0] // Placeholder empty slice - replace this } // 4. Extract a subslice based on a condition (e.g., all positive numbers) fn extract_positive(numbers: /* TODO: Add parameter type for a slice of integers */) -> /* TODO: Return type */ { // TODO: Find the first continuous run of positive numbers in the slice and return it as a slice // If the slice starts with a positive number, return from start until the first non-positive // If the slice starts with a non-positive, find the first positive and return from there until the next non-positive // If no positives are found, return an empty slice &numbers[0..0] // Placeholder empty slice - replace this } fn main() { // 1. Test first_word function let sentence = String::from(\"Hello Rust slices world\"); let first = first_word(/* TODO: Pass the string as a slice */); println!(\"First word: {}\", first); let empty_str = String::from(\"\"); let first_empty = first_word(/* TODO: Pass the empty string as a slice */); println!(\"First word in empty string: '{}'\", first_empty); // 2. Test sum_slice function let numbers = [1, 2, 3, 4, 5]; let sum = sum_slice(/* TODO: Pass the array as a slice */); println!(\"Sum of all elements: {}\", sum); let partial_sum = sum_slice(/* TODO: Pass a slice of part of the array */); println!(\"Sum of first three elements: {}\", partial_sum); // 3. Test middle_elements function let vec1 = vec![1, 2, 3, 4, 5]; // Odd length let mid1 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of odd-length vector: {:?}\", mid1); let vec2 = vec![1, 2, 3, 4]; // Even length let mid2 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of even-length vector: {:?}\", mid2); // 4. Test extract_positive function let mixed_numbers = [3, 5, 2, -1, -5, 8, 10, -3]; let positive_run = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers: {:?}\", positive_run); let negative_start = [-2, -5, 3, 4, 5, -1, 7]; let positive_run2 = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers (starting negative): {:?}\", positive_run2); } How to Run Your Code First, modify the starter code in 03_slice_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_03 Expected Output First word: Hello First word in empty string: '' Sum of all elements: 15 Sum of first three elements: 6 Middle element(s) of odd-length vector: [3] Middle element(s) of even-length vector: [2, 3] First run of positive numbers: [3, 5, 2] First run of positive numbers (starting negative): [3, 4, 5] Tips String slices are written as &str Array/vector slices are written as &[T] where T is the element type Use indexing with ranges to create slices: &s[0..5] Remember that string indices must be at valid UTF-8 character boundaries For the first_word function, use .bytes() and .enumerate() to find a space character For generic slices, you can use &[T] where T is a generic type parameter Use .iter() to iterate over slice elements, or index directly with slice[i]","title":"Slice Workshop"},{"location":"module2-memory-management/exercises/03_slice_workshop/#exercise-3-slice-workshop","text":"","title":"Exercise 3: Slice Workshop"},{"location":"module2-memory-management/exercises/03_slice_workshop/#problem-statement","text":"Write a Rust program that demonstrates effective use of slices by: Creating a function that takes a string slice and returns the first word Creating a function that takes an array slice and returns the sum of its elements Implementing a function that finds the middle element(s) of a slice Creating a function that extracts a specific part of a slice based on a condition","title":"Problem Statement"},{"location":"module2-memory-management/exercises/03_slice_workshop/#learning-objectives","text":"Understand what slices are and how they differ from full collections Learn to use string slices effectively Practice working with array and vector slices Understand the relationship between slices and references","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/03_slice_workshop/#starter-code","text":"// 1. Find the first word in a string fn first_word(s: /* TODO: Add parameter type for a string slice */) -> /* TODO: Return type */ { // TODO: Return the first word in the string (up to the first space or the entire string if no spaces) \"\" } // 2. Calculate the sum of elements in an array slice fn sum_slice(numbers: /* TODO: Add parameter type for a slice of integers */) -> i32 { // TODO: Calculate and return the sum of all elements in the slice 0 } // 3. Find the middle element(s) of a slice fn middle_elements(slice: /* TODO: Add parameter type for a generic slice */) -> /* TODO: Return type */ { // TODO: Return the middle element if length is odd, or the two middle elements if length is even // Hint: For a generic implementation, you'll need to handle both cases if slice.len() % 2 == 1 { // Odd length - return a slice containing just the middle element } else { // Even length - return a slice containing the two middle elements } &slice[0..0] // Placeholder empty slice - replace this } // 4. Extract a subslice based on a condition (e.g., all positive numbers) fn extract_positive(numbers: /* TODO: Add parameter type for a slice of integers */) -> /* TODO: Return type */ { // TODO: Find the first continuous run of positive numbers in the slice and return it as a slice // If the slice starts with a positive number, return from start until the first non-positive // If the slice starts with a non-positive, find the first positive and return from there until the next non-positive // If no positives are found, return an empty slice &numbers[0..0] // Placeholder empty slice - replace this } fn main() { // 1. Test first_word function let sentence = String::from(\"Hello Rust slices world\"); let first = first_word(/* TODO: Pass the string as a slice */); println!(\"First word: {}\", first); let empty_str = String::from(\"\"); let first_empty = first_word(/* TODO: Pass the empty string as a slice */); println!(\"First word in empty string: '{}'\", first_empty); // 2. Test sum_slice function let numbers = [1, 2, 3, 4, 5]; let sum = sum_slice(/* TODO: Pass the array as a slice */); println!(\"Sum of all elements: {}\", sum); let partial_sum = sum_slice(/* TODO: Pass a slice of part of the array */); println!(\"Sum of first three elements: {}\", partial_sum); // 3. Test middle_elements function let vec1 = vec![1, 2, 3, 4, 5]; // Odd length let mid1 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of odd-length vector: {:?}\", mid1); let vec2 = vec![1, 2, 3, 4]; // Even length let mid2 = middle_elements(/* TODO: Pass the vector as a slice */); println!(\"Middle element(s) of even-length vector: {:?}\", mid2); // 4. Test extract_positive function let mixed_numbers = [3, 5, 2, -1, -5, 8, 10, -3]; let positive_run = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers: {:?}\", positive_run); let negative_start = [-2, -5, 3, 4, 5, -1, 7]; let positive_run2 = extract_positive(/* TODO: Pass the array as a slice */); println!(\"First run of positive numbers (starting negative): {:?}\", positive_run2); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/03_slice_workshop/#how-to-run-your-code","text":"First, modify the starter code in 03_slice_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_03","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/03_slice_workshop/#expected-output","text":"First word: Hello First word in empty string: '' Sum of all elements: 15 Sum of first three elements: 6 Middle element(s) of odd-length vector: [3] Middle element(s) of even-length vector: [2, 3] First run of positive numbers: [3, 5, 2] First run of positive numbers (starting negative): [3, 4, 5]","title":"Expected Output"},{"location":"module2-memory-management/exercises/03_slice_workshop/#tips","text":"String slices are written as &str Array/vector slices are written as &[T] where T is the element type Use indexing with ranges to create slices: &s[0..5] Remember that string indices must be at valid UTF-8 character boundaries For the first_word function, use .bytes() and .enumerate() to find a space character For generic slices, you can use &[T] where T is a generic type parameter Use .iter() to iterate over slice elements, or index directly with slice[i]","title":"Tips"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/","text":"Exercise 4: Memory Management Debugging Problem Statement Debug and fix memory management issues in existing Rust code. You will: Fix code with ownership errors Resolve borrowing conflicts Repair code with dangling references Fix lifetime problems Optimize code to avoid unnecessary cloning Learning Objectives Practice identifying common memory management errors in Rust Learn to read and understand Rust compiler error messages Apply the concepts of ownership, borrowing, and lifetimes to fix bugs Develop strategies for writing memory-safe code Starter Code // Uncomment each section one at a time and fix the issues // Problem 1: Fix ownership errors // fn problem1() { // // 1.1: Fix the double-move error // let data = vec![1, 2, 3]; // let x = data; // let y = data; // Trying to use data after move // println!(\"{:?} {:?}\", x, y); // // // 1.2: Fix the ownership issue with the function // let name = String::from(\"Rust\"); // print_data(name); // println!(\"My name is {}\", name); // Trying to use name after move // } // // fn print_data(data: String) { // println!(\"Data: {}\", data); // } // Problem 2: Fix borrowing conflicts // fn problem2() { // // 2.1: Fix the mutable/immutable borrow conflict // let mut numbers = vec![1, 2, 3]; // let first = &numbers[0]; // numbers.push(4); // println!(\"First element is: {}\", first); // // // 2.2: Fix the multiple mutable borrows // let mut data = String::from(\"Hello\"); // let ref1 = &mut data; // let ref2 = &mut data; // *ref1 = String::from(\"Hello, \"); // *ref2 = ref2.to_string() + \"Rust!\"; // println!(\"Data: {}\", data); // } // Problem 3: Fix dangling references // fn problem3() { // // 3.1: Fix the dangling reference returned by the function // let result = get_string(); // println!(\"Result: {}\", result); // // // 3.2: Fix the issue with references outliving the data // let reference; // { // let data = vec![1, 2, 3]; // reference = &data; // } // println!(\"Reference: {:?}\", reference); // } // // fn get_string() -> &String { // let s = String::from(\"I am a dangling reference\"); // &s // } // Problem 4: Fix lifetime problems // fn problem4() { // // 4.1: Fix the function signature to properly handle lifetimes // let string1 = String::from(\"long string is long\"); // let result; // { // let string2 = String::from(\"short\"); // result = longest(string1.as_str(), string2.as_str()); // } // println!(\"Longest string: {}\", result); // } // // fn longest(x: &str, y: &str) -> &str { // if x.len() > y.len() { // x // } else { // y // } // } // Problem 5: Optimize unnecessary cloning // fn problem5() { // // 5.1: Remove unnecessary clones while keeping the code functional // let original = String::from(\"Rust Programming\"); // let cloned = original.clone(); // let len = calculate_length(cloned.clone()); // // let mut names = Vec::new(); // names.push(String::from(\"Alice\")); // names.push(String::from(\"Bob\")); // // for name in names.clone() { // print_string(name.clone()); // } // // println!(\"Original is still: {}\", original); // println!(\"Length was: {}\", len); // println!(\"Names: {:?}\", names); // } // // fn calculate_length(s: String) -> usize { // s.len() // } // // fn print_string(s: String) { // println!(\"{}\", s); // } fn main() { println!(\"Uncomment and fix each problem section one by one.\"); println!(\"Once fixed, you can run each problem function from main.\"); // Uncomment these as you fix each problem: // problem1(); // problem2(); // problem3(); // problem4(); // problem5(); } How to Run Your Code First, modify the starter code in 04_memory_management_debugging_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_04 Expected Output After fixing all issues, running the code should produce output like: Uncomment and fix each problem section one by one. Once fixed, you can run each problem function from main. # Problem 1 output: [1, 2, 3] [1, 2, 3] Data: Rust My name is Rust # Problem 2 output: First element is: 1 Data: Hello, Rust! # Problem 3 output: Result: I am a dangling reference Reference: [1, 2, 3] # Problem 4 output: Longest string: long string is long # Problem 5 output: Alice Bob Original is still: Rust Programming Length was: 16 Names: [\"Alice\", \"Bob\"] Tips Read the Rust compiler errors carefully - they often tell you exactly what's wrong Consider using clone() when you need to duplicate data, but remove clones when unnecessary Remember to use references ( & and &mut ) to avoid transferring ownership Use lifetimes when functions need to return references Think about the scope of variables and when they are dropped For problems with dangling references, consider returning owned data or extending lifetimes","title":"Memory Management Debugging"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#exercise-4-memory-management-debugging","text":"","title":"Exercise 4: Memory Management Debugging"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#problem-statement","text":"Debug and fix memory management issues in existing Rust code. You will: Fix code with ownership errors Resolve borrowing conflicts Repair code with dangling references Fix lifetime problems Optimize code to avoid unnecessary cloning","title":"Problem Statement"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#learning-objectives","text":"Practice identifying common memory management errors in Rust Learn to read and understand Rust compiler error messages Apply the concepts of ownership, borrowing, and lifetimes to fix bugs Develop strategies for writing memory-safe code","title":"Learning Objectives"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#starter-code","text":"// Uncomment each section one at a time and fix the issues // Problem 1: Fix ownership errors // fn problem1() { // // 1.1: Fix the double-move error // let data = vec![1, 2, 3]; // let x = data; // let y = data; // Trying to use data after move // println!(\"{:?} {:?}\", x, y); // // // 1.2: Fix the ownership issue with the function // let name = String::from(\"Rust\"); // print_data(name); // println!(\"My name is {}\", name); // Trying to use name after move // } // // fn print_data(data: String) { // println!(\"Data: {}\", data); // } // Problem 2: Fix borrowing conflicts // fn problem2() { // // 2.1: Fix the mutable/immutable borrow conflict // let mut numbers = vec![1, 2, 3]; // let first = &numbers[0]; // numbers.push(4); // println!(\"First element is: {}\", first); // // // 2.2: Fix the multiple mutable borrows // let mut data = String::from(\"Hello\"); // let ref1 = &mut data; // let ref2 = &mut data; // *ref1 = String::from(\"Hello, \"); // *ref2 = ref2.to_string() + \"Rust!\"; // println!(\"Data: {}\", data); // } // Problem 3: Fix dangling references // fn problem3() { // // 3.1: Fix the dangling reference returned by the function // let result = get_string(); // println!(\"Result: {}\", result); // // // 3.2: Fix the issue with references outliving the data // let reference; // { // let data = vec![1, 2, 3]; // reference = &data; // } // println!(\"Reference: {:?}\", reference); // } // // fn get_string() -> &String { // let s = String::from(\"I am a dangling reference\"); // &s // } // Problem 4: Fix lifetime problems // fn problem4() { // // 4.1: Fix the function signature to properly handle lifetimes // let string1 = String::from(\"long string is long\"); // let result; // { // let string2 = String::from(\"short\"); // result = longest(string1.as_str(), string2.as_str()); // } // println!(\"Longest string: {}\", result); // } // // fn longest(x: &str, y: &str) -> &str { // if x.len() > y.len() { // x // } else { // y // } // } // Problem 5: Optimize unnecessary cloning // fn problem5() { // // 5.1: Remove unnecessary clones while keeping the code functional // let original = String::from(\"Rust Programming\"); // let cloned = original.clone(); // let len = calculate_length(cloned.clone()); // // let mut names = Vec::new(); // names.push(String::from(\"Alice\")); // names.push(String::from(\"Bob\")); // // for name in names.clone() { // print_string(name.clone()); // } // // println!(\"Original is still: {}\", original); // println!(\"Length was: {}\", len); // println!(\"Names: {:?}\", names); // } // // fn calculate_length(s: String) -> usize { // s.len() // } // // fn print_string(s: String) { // println!(\"{}\", s); // } fn main() { println!(\"Uncomment and fix each problem section one by one.\"); println!(\"Once fixed, you can run each problem function from main.\"); // Uncomment these as you fix each problem: // problem1(); // problem2(); // problem3(); // problem4(); // problem5(); }","title":"Starter Code"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#how-to-run-your-code","text":"First, modify the starter code in 04_memory_management_debugging_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module2_04","title":"How to Run Your Code"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#expected-output","text":"After fixing all issues, running the code should produce output like: Uncomment and fix each problem section one by one. Once fixed, you can run each problem function from main. # Problem 1 output: [1, 2, 3] [1, 2, 3] Data: Rust My name is Rust # Problem 2 output: First element is: 1 Data: Hello, Rust! # Problem 3 output: Result: I am a dangling reference Reference: [1, 2, 3] # Problem 4 output: Longest string: long string is long # Problem 5 output: Alice Bob Original is still: Rust Programming Length was: 16 Names: [\"Alice\", \"Bob\"]","title":"Expected Output"},{"location":"module2-memory-management/exercises/04_memory_management_debugging/#tips","text":"Read the Rust compiler errors carefully - they often tell you exactly what's wrong Consider using clone() when you need to duplicate data, but remove clones when unnecessary Remember to use references ( & and &mut ) to avoid transferring ownership Use lifetimes when functions need to return references Think about the scope of variables and when they are dropped For problems with dangling references, consider returning owned data or extending lifetimes","title":"Tips"},{"location":"module3-data-types/","text":"Module 3: Data Types Core Module Learning Objectives Master Rust's struct and enum data structures Learn how to implement methods and associated functions Understand pattern matching and its applications Work with option and result types for error handling Content Summary This module covers Rust's custom data types, including structs and enums, which are fundamental to writing organized and type-safe code in Rust. You'll learn how to define and use these types, implement methods, and leverage Rust's powerful pattern matching capabilities. Topics Covered Structs Defining and creating structs Struct update syntax Methods and associated functions Tuple structs and unit structs Enums Defining enums Enums with data The Option<T> enum The Result<T, E> enum Pattern Matching match expressions Patterns and matching if let syntax while let syntax Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Library System - Create a library management system using structs and methods Error Handling - Practice using Option and Result types for robust error handling Resources The Rust Programming Language Book - Chapters 5-6 Rust By Example - Structs and Enums Rustlings Exercises - Structs and Enums","title":"Overview"},{"location":"module3-data-types/#module-3-data-types","text":"","title":"Module 3: Data Types"},{"location":"module3-data-types/#core-module","text":"","title":"Core Module"},{"location":"module3-data-types/#learning-objectives","text":"Master Rust's struct and enum data structures Learn how to implement methods and associated functions Understand pattern matching and its applications Work with option and result types for error handling","title":"Learning Objectives"},{"location":"module3-data-types/#content-summary","text":"This module covers Rust's custom data types, including structs and enums, which are fundamental to writing organized and type-safe code in Rust. You'll learn how to define and use these types, implement methods, and leverage Rust's powerful pattern matching capabilities.","title":"Content Summary"},{"location":"module3-data-types/#topics-covered","text":"Structs Defining and creating structs Struct update syntax Methods and associated functions Tuple structs and unit structs Enums Defining enums Enums with data The Option<T> enum The Result<T, E> enum Pattern Matching match expressions Patterns and matching if let syntax while let syntax","title":"Topics Covered"},{"location":"module3-data-types/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Library System - Create a library management system using structs and methods Error Handling - Practice using Option and Result types for robust error handling","title":"Exercises"},{"location":"module3-data-types/#resources","text":"The Rust Programming Language Book - Chapters 5-6 Rust By Example - Structs and Enums Rustlings Exercises - Structs and Enums","title":"Resources"},{"location":"module3-data-types/exercises/01_library_system/","text":"Exercise 1: Library Management System Problem Statement Create a library management system in Rust that uses structs and methods to track books and their borrowing status. The system should be able to: Add new books to the library Allow users to borrow and return books Display information about books and their availability Learning Objectives Practice defining and working with structs Implement methods for structs Use enums to represent different states Apply ownership principles to struct fields Starter Code // Define the Book struct struct Book { // TODO: Add fields for book properties (title, author, year, isbn) } // Define a BookStatus enum to track availability enum BookStatus { // TODO: Add variants for different states (Available, Borrowed) } // Define a Library struct to manage books struct Library { // TODO: Add fields to store books and their status } // TODO: Implement methods for the Library struct impl Library { // Create a new, empty library fn new() -> Library { // TODO: Implement this function } // Add a book to the library fn add_book(&mut self, book: Book) { // TODO: Implement this function } // Borrow a book from the library fn borrow_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // Return a borrowed book to the library fn return_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // List all books in the library with their status fn list_books(&self) { // TODO: Implement this function } } fn main() { // TODO: Create a new library // TODO: Add several books to the library // TODO: Borrow and return books // TODO: List the books and their status } How to Run Your Code First, modify the starter code in 01_library_system_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module3_01 Expected Output When implemented correctly, running your program should produce output similar to: Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Borrowing \"Clean Code\"... Book borrowed successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Borrowed Returning \"Clean Code\"... Book returned successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Tips Use appropriate data structures to store multiple books and their status Think about how to represent the relationship between books and their status Remember to handle errors for cases like borrowing unavailable books or returning books that weren't borrowed Consider using the Hash trait for efficient lookups","title":"Library System"},{"location":"module3-data-types/exercises/01_library_system/#exercise-1-library-management-system","text":"","title":"Exercise 1: Library Management System"},{"location":"module3-data-types/exercises/01_library_system/#problem-statement","text":"Create a library management system in Rust that uses structs and methods to track books and their borrowing status. The system should be able to: Add new books to the library Allow users to borrow and return books Display information about books and their availability","title":"Problem Statement"},{"location":"module3-data-types/exercises/01_library_system/#learning-objectives","text":"Practice defining and working with structs Implement methods for structs Use enums to represent different states Apply ownership principles to struct fields","title":"Learning Objectives"},{"location":"module3-data-types/exercises/01_library_system/#starter-code","text":"// Define the Book struct struct Book { // TODO: Add fields for book properties (title, author, year, isbn) } // Define a BookStatus enum to track availability enum BookStatus { // TODO: Add variants for different states (Available, Borrowed) } // Define a Library struct to manage books struct Library { // TODO: Add fields to store books and their status } // TODO: Implement methods for the Library struct impl Library { // Create a new, empty library fn new() -> Library { // TODO: Implement this function } // Add a book to the library fn add_book(&mut self, book: Book) { // TODO: Implement this function } // Borrow a book from the library fn borrow_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // Return a borrowed book to the library fn return_book(&mut self, isbn: &str) -> Result<&Book, &str> { // TODO: Implement this function } // List all books in the library with their status fn list_books(&self) { // TODO: Implement this function } } fn main() { // TODO: Create a new library // TODO: Add several books to the library // TODO: Borrow and return books // TODO: List the books and their status }","title":"Starter Code"},{"location":"module3-data-types/exercises/01_library_system/#how-to-run-your-code","text":"First, modify the starter code in 01_library_system_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module3_01","title":"How to Run Your Code"},{"location":"module3-data-types/exercises/01_library_system/#expected-output","text":"When implemented correctly, running your program should produce output similar to: Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available Borrowing \"Clean Code\"... Book borrowed successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Borrowed Returning \"Clean Code\"... Book returned successfully! Library Book Inventory: \"The Rust Programming Language\" by Steve Klabnik and Carol Nichols (2018) - Available \"Design Patterns\" by Erich Gamma et al. (1994) - Available \"Clean Code\" by Robert C. Martin (2008) - Available","title":"Expected Output"},{"location":"module3-data-types/exercises/01_library_system/#tips","text":"Use appropriate data structures to store multiple books and their status Think about how to represent the relationship between books and their status Remember to handle errors for cases like borrowing unavailable books or returning books that weren't borrowed Consider using the Hash trait for efficient lookups","title":"Tips"},{"location":"module3-data-types/exercises/02_error_handling/","text":"Exercise 2: Error Handling Workshop Problem Statement Write a Rust program that demonstrates effective error handling by: Creating a function that parses user configuration from a string and returns a Result type Implementing a function that safely converts a string to an integer using the Option type Developing a data validation system with custom error types Building a function chain that propagates errors using the ? operator Learning Objectives Understand when and how to use Option<T> and Result<T, E> types Learn to handle errors in a clean, idiomatic way using Rust's error handling patterns Practice defining and working with custom error types Become comfortable with error propagation techniques Starter Code use std::num::ParseIntError; use std::fmt; // Part 1: Configuration Parser // Create a configuration struct and parser that returns Results // Config struct - already defined #[derive(Debug)] struct Config { username: String, timeout: u32, max_retries: u32, } // Custom error type for configuration parsing errors - already defined with variants #[derive(Debug)] enum ConfigError { MissingField(String), InvalidTimeout(String), InvalidRetryCount(String), } // Display implementation for ConfigError - just needs message content impl fmt::Display for ConfigError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ConfigError::MissingField(field) => write!(f, \"Missing required field: {}\", field), ConfigError::InvalidTimeout(val) => write!(f, \"Invalid timeout value: {}\", val), ConfigError::InvalidRetryCount(val) => write!(f, \"Invalid retry count: {}\", val), } } } // Parse configuration string function - implementation needed fn parse_config(config_str: &str) -> Result<Config, ConfigError> { let mut username = None; let mut timeout = None; let mut max_retries = None; // Split the configuration string by commas and process each key-value pair for pair in config_str.split(',') { let parts: Vec<&str> = pair.split('=').collect(); if parts.len() != 2 { continue; // Skip invalid pairs } let key = parts[0].trim(); let value = parts[1].trim(); match key { \"username\" => username = Some(value.to_string()), \"timeout\" => { match value.parse::<u32>() { Ok(val) => timeout = Some(val), Err(_) => return Err(ConfigError::InvalidTimeout(value.to_string())), } }, \"max_retries\" => { match value.parse::<u32>() { Ok(val) => max_retries = Some(val), Err(_) => return Err(ConfigError::InvalidRetryCount(value.to_string())), } }, _ => {} // Ignore unknown keys } } let username = username.ok_or(ConfigError::MissingField(\"username\".to_string()))?; let timeout = timeout.ok_or(ConfigError::MissingField(\"timeout\".to_string()))?; let max_retries = max_retries.ok_or(ConfigError::MissingField(\"max_retries\".to_string()))?; Ok(Config { username, timeout, max_retries, }) } // Part 2: Safe String to Integer Conversion // Create a function that safely converts a string to an integer fn parse_number(s: &str) -> Option<i32> { match s.parse::<i32>() { Ok(number) => Some(number), Err(_) => None, } } // Part 3: Data Validation with Custom Errors // Implement a user data validator with multiple error types // User struct - already defined #[derive(Debug)] struct User { id: u32, name: String, age: u32, } // ValidationError enum - already defined with variants #[derive(Debug)] enum ValidationError { InvalidId, NameTooShort, InvalidAge, } // Display implementation for ValidationError impl fmt::Display for ValidationError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ValidationError::InvalidId => write!(f, /* TODO */), ValidationError::NameTooShort => write!(f, /* TODO */), ValidationError::InvalidAge => write!(f, /* TODO */), } } } // Validate user function - partially implemented fn validate_user(user: &User) -> Result<(), ValidationError> { // Check ID validity if user.id == 0 { return /* TODO */; } if user.name.len() < 2 { return /* TODO */; } if user.age < 18 { return /* TODO */; } Ok(()) } // Part 4: Error Propagation Chain // Create a series of functions that use the ? operator to propagate errors // ProcessError type #[derive(Debug)] enum ProcessError { ConfigError(ConfigError), ParseError(ParseIntError), ValidationError(ValidationError), } // From implementations for automatic conversions impl From<ConfigError> for ProcessError { fn from(err: ConfigError) -> Self { ProcessError::ConfigError(err) } } impl From<ParseIntError> for ProcessError { fn from(err: ParseIntError) -> Self { ProcessError::ParseError(err) } } impl From<ValidationError> for ProcessError { fn from(err: ValidationError) -> Self { ProcessError::ValidationError(err) } } impl fmt::Display for ProcessError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ProcessError::ConfigError(e) => write!(f, \"Configuration error: {}\", e), ProcessError::ParseError(e) => write!(f, \"Parse error: {}\", e), ProcessError::ValidationError(e) => write!(f, \"Validation error: {}\", e), } } } // Process data function - needs implementation with ? operator fn process_data(config_str: &str, user_id: &str, user_name: &str, user_age: &str) -> Result<(), ProcessError> { let config = parse_config(config_str)?; let id: u32 = user_id.parse()?; let age: u32 = user_age.parse()?; let user = User { id, name: user_name.to_string(), age, }; validate_user(&user)?; Ok(()) } fn main() { // Part 1: Test the configuration parser println!(\"--- Part 1: Configuration Parser ---\"); let config_str = \"username=alice,timeout=30,max_retries=5\"; match parse_config(config_str) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } let invalid_config = \"username=bob,timeout=invalid,max_retries=5\"; match parse_config(invalid_config) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } // Part 2: Test the string to integer conversion println!(\"\\n--- Part 2: String to Integer Conversion ---\"); let valid_number = \"42\"; let invalid_number = \"four\"; match parse_number(valid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", valid_number, num), None => println!(\"Failed to parse '{}'\", valid_number), } match parse_number(invalid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", invalid_number, num), None => println!(\"Failed to parse '{}'\", invalid_number), } // Part 3: Test the user validation println!(\"\\n--- Part 3: User Validation ---\"); // Create and test valid and invalid users let valid_user = User { id: 1001, name: String::from(\"Charlie\"), age: 25, }; let invalid_user1 = User { id: 1002, name: String::from(\"D\"), // Too short age: 30, }; let invalid_user2 = User { id: 1003, name: String::from(\"Eve\"), age: 17, // Too young }; println!(\"Validating user: {:?}\", valid_user); match validate_user(&valid_user) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user1); match validate_user(&invalid_user1) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user2); match validate_user(&invalid_user2) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } // Part 4: Test the error propagation chain println!(\"\\n--- Part 4: Error Propagation ---\"); let test_cases = [ (\"username=charlie,timeout=30,max_retries=5\", \"1001\", \"Charlie\", \"25\"), (\"username=diana,timeout=invalid,max_retries=5\", \"1002\", \"Diana\", \"30\"), (\"username=eve,timeout=30,max_retries=5\", \"invalid_id\", \"Eve\", \"22\"), (\"username=frank,timeout=30,max_retries=5\", \"1004\", \"F\", \"17\"), // Invalid name (too short) ]; for (config, id, name, age) in test_cases.iter() { println!(\"Processing: Config='{}', ID='{}', Name='{}', Age='{}'\", config, id, name, age); match process_data(config, id, name, age) { Ok(()) => println!(\" Success: Data processed successfully\"), Err(e) => println!(\" Error: {}\", e), } } } How to Run Your Code First, modify the starter code in 02_error_handling_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_02 Expected Output After correctly implementing all parts, your program should produce output similar to: --- Part 1: Configuration Parser --- Config parsed successfully: Config { username: \"alice\", timeout: 30, max_retries: 5 } Failed to parse config: Invalid timeout value: invalid --- Part 2: String to Integer Conversion --- Successfully parsed '42' to 42 Failed to parse 'four' --- Part 3: User Validation --- Validating user: User { id: 1001, name: \"Charlie\", age: 25 } User is valid Validating user: User { id: 1002, name: \"D\", age: 30 } Validation error: Name too short, minimum length is 2 characters Validating user: User { id: 1003, name: \"Eve\", age: 17 } Validation error: Age must be at least 18 --- Part 4: Error Propagation --- Processing: Config='username=charlie,timeout=30,max_retries=5', ID='1001', Name='Charlie', Age='25' Success: Data processed successfully Processing: Config='username=diana,timeout=invalid,max_retries=5', ID='1002', Name='Diana', Age='30' Error: Configuration error: Invalid timeout value: invalid Processing: Config='username=eve,timeout=30,max_retries=5', ID='invalid_id', Name='Eve', Age='22' Error: Parse error: invalid digit found in string Processing: Config='username=frank,timeout=30,max_retries=5', ID='1004', Name='F', Age='17' Error: Validation error: Name too short, minimum length is 2 characters Tips Use match expressions to handle Option and Result types Remember that the Display trait is used to format error messages for end users The ? operator can be used to automatically propagate errors in functions that return Result Use the parse method to convert strings to numbers, which returns a Result The From trait is used for automatic conversions between error types when using the ? operator","title":"Error Handling"},{"location":"module3-data-types/exercises/02_error_handling/#exercise-2-error-handling-workshop","text":"","title":"Exercise 2: Error Handling Workshop"},{"location":"module3-data-types/exercises/02_error_handling/#problem-statement","text":"Write a Rust program that demonstrates effective error handling by: Creating a function that parses user configuration from a string and returns a Result type Implementing a function that safely converts a string to an integer using the Option type Developing a data validation system with custom error types Building a function chain that propagates errors using the ? operator","title":"Problem Statement"},{"location":"module3-data-types/exercises/02_error_handling/#learning-objectives","text":"Understand when and how to use Option<T> and Result<T, E> types Learn to handle errors in a clean, idiomatic way using Rust's error handling patterns Practice defining and working with custom error types Become comfortable with error propagation techniques","title":"Learning Objectives"},{"location":"module3-data-types/exercises/02_error_handling/#starter-code","text":"use std::num::ParseIntError; use std::fmt; // Part 1: Configuration Parser // Create a configuration struct and parser that returns Results // Config struct - already defined #[derive(Debug)] struct Config { username: String, timeout: u32, max_retries: u32, } // Custom error type for configuration parsing errors - already defined with variants #[derive(Debug)] enum ConfigError { MissingField(String), InvalidTimeout(String), InvalidRetryCount(String), } // Display implementation for ConfigError - just needs message content impl fmt::Display for ConfigError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ConfigError::MissingField(field) => write!(f, \"Missing required field: {}\", field), ConfigError::InvalidTimeout(val) => write!(f, \"Invalid timeout value: {}\", val), ConfigError::InvalidRetryCount(val) => write!(f, \"Invalid retry count: {}\", val), } } } // Parse configuration string function - implementation needed fn parse_config(config_str: &str) -> Result<Config, ConfigError> { let mut username = None; let mut timeout = None; let mut max_retries = None; // Split the configuration string by commas and process each key-value pair for pair in config_str.split(',') { let parts: Vec<&str> = pair.split('=').collect(); if parts.len() != 2 { continue; // Skip invalid pairs } let key = parts[0].trim(); let value = parts[1].trim(); match key { \"username\" => username = Some(value.to_string()), \"timeout\" => { match value.parse::<u32>() { Ok(val) => timeout = Some(val), Err(_) => return Err(ConfigError::InvalidTimeout(value.to_string())), } }, \"max_retries\" => { match value.parse::<u32>() { Ok(val) => max_retries = Some(val), Err(_) => return Err(ConfigError::InvalidRetryCount(value.to_string())), } }, _ => {} // Ignore unknown keys } } let username = username.ok_or(ConfigError::MissingField(\"username\".to_string()))?; let timeout = timeout.ok_or(ConfigError::MissingField(\"timeout\".to_string()))?; let max_retries = max_retries.ok_or(ConfigError::MissingField(\"max_retries\".to_string()))?; Ok(Config { username, timeout, max_retries, }) } // Part 2: Safe String to Integer Conversion // Create a function that safely converts a string to an integer fn parse_number(s: &str) -> Option<i32> { match s.parse::<i32>() { Ok(number) => Some(number), Err(_) => None, } } // Part 3: Data Validation with Custom Errors // Implement a user data validator with multiple error types // User struct - already defined #[derive(Debug)] struct User { id: u32, name: String, age: u32, } // ValidationError enum - already defined with variants #[derive(Debug)] enum ValidationError { InvalidId, NameTooShort, InvalidAge, } // Display implementation for ValidationError impl fmt::Display for ValidationError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ValidationError::InvalidId => write!(f, /* TODO */), ValidationError::NameTooShort => write!(f, /* TODO */), ValidationError::InvalidAge => write!(f, /* TODO */), } } } // Validate user function - partially implemented fn validate_user(user: &User) -> Result<(), ValidationError> { // Check ID validity if user.id == 0 { return /* TODO */; } if user.name.len() < 2 { return /* TODO */; } if user.age < 18 { return /* TODO */; } Ok(()) } // Part 4: Error Propagation Chain // Create a series of functions that use the ? operator to propagate errors // ProcessError type #[derive(Debug)] enum ProcessError { ConfigError(ConfigError), ParseError(ParseIntError), ValidationError(ValidationError), } // From implementations for automatic conversions impl From<ConfigError> for ProcessError { fn from(err: ConfigError) -> Self { ProcessError::ConfigError(err) } } impl From<ParseIntError> for ProcessError { fn from(err: ParseIntError) -> Self { ProcessError::ParseError(err) } } impl From<ValidationError> for ProcessError { fn from(err: ValidationError) -> Self { ProcessError::ValidationError(err) } } impl fmt::Display for ProcessError { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { match self { ProcessError::ConfigError(e) => write!(f, \"Configuration error: {}\", e), ProcessError::ParseError(e) => write!(f, \"Parse error: {}\", e), ProcessError::ValidationError(e) => write!(f, \"Validation error: {}\", e), } } } // Process data function - needs implementation with ? operator fn process_data(config_str: &str, user_id: &str, user_name: &str, user_age: &str) -> Result<(), ProcessError> { let config = parse_config(config_str)?; let id: u32 = user_id.parse()?; let age: u32 = user_age.parse()?; let user = User { id, name: user_name.to_string(), age, }; validate_user(&user)?; Ok(()) } fn main() { // Part 1: Test the configuration parser println!(\"--- Part 1: Configuration Parser ---\"); let config_str = \"username=alice,timeout=30,max_retries=5\"; match parse_config(config_str) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } let invalid_config = \"username=bob,timeout=invalid,max_retries=5\"; match parse_config(invalid_config) { Ok(config) => println!(\"Config parsed successfully: {:?}\", config), Err(e) => println!(\"Failed to parse config: {}\", e), } // Part 2: Test the string to integer conversion println!(\"\\n--- Part 2: String to Integer Conversion ---\"); let valid_number = \"42\"; let invalid_number = \"four\"; match parse_number(valid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", valid_number, num), None => println!(\"Failed to parse '{}'\", valid_number), } match parse_number(invalid_number) { Some(num) => println!(\"Successfully parsed '{}' to {}\", invalid_number, num), None => println!(\"Failed to parse '{}'\", invalid_number), } // Part 3: Test the user validation println!(\"\\n--- Part 3: User Validation ---\"); // Create and test valid and invalid users let valid_user = User { id: 1001, name: String::from(\"Charlie\"), age: 25, }; let invalid_user1 = User { id: 1002, name: String::from(\"D\"), // Too short age: 30, }; let invalid_user2 = User { id: 1003, name: String::from(\"Eve\"), age: 17, // Too young }; println!(\"Validating user: {:?}\", valid_user); match validate_user(&valid_user) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user1); match validate_user(&invalid_user1) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } println!(\"Validating user: {:?}\", invalid_user2); match validate_user(&invalid_user2) { Ok(()) => println!(\"User is valid\"), Err(e) => println!(\"Validation error: {}\", e), } // Part 4: Test the error propagation chain println!(\"\\n--- Part 4: Error Propagation ---\"); let test_cases = [ (\"username=charlie,timeout=30,max_retries=5\", \"1001\", \"Charlie\", \"25\"), (\"username=diana,timeout=invalid,max_retries=5\", \"1002\", \"Diana\", \"30\"), (\"username=eve,timeout=30,max_retries=5\", \"invalid_id\", \"Eve\", \"22\"), (\"username=frank,timeout=30,max_retries=5\", \"1004\", \"F\", \"17\"), // Invalid name (too short) ]; for (config, id, name, age) in test_cases.iter() { println!(\"Processing: Config='{}', ID='{}', Name='{}', Age='{}'\", config, id, name, age); match process_data(config, id, name, age) { Ok(()) => println!(\" Success: Data processed successfully\"), Err(e) => println!(\" Error: {}\", e), } } }","title":"Starter Code"},{"location":"module3-data-types/exercises/02_error_handling/#how-to-run-your-code","text":"First, modify the starter code in 02_error_handling_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_02","title":"How to Run Your Code"},{"location":"module3-data-types/exercises/02_error_handling/#expected-output","text":"After correctly implementing all parts, your program should produce output similar to: --- Part 1: Configuration Parser --- Config parsed successfully: Config { username: \"alice\", timeout: 30, max_retries: 5 } Failed to parse config: Invalid timeout value: invalid --- Part 2: String to Integer Conversion --- Successfully parsed '42' to 42 Failed to parse 'four' --- Part 3: User Validation --- Validating user: User { id: 1001, name: \"Charlie\", age: 25 } User is valid Validating user: User { id: 1002, name: \"D\", age: 30 } Validation error: Name too short, minimum length is 2 characters Validating user: User { id: 1003, name: \"Eve\", age: 17 } Validation error: Age must be at least 18 --- Part 4: Error Propagation --- Processing: Config='username=charlie,timeout=30,max_retries=5', ID='1001', Name='Charlie', Age='25' Success: Data processed successfully Processing: Config='username=diana,timeout=invalid,max_retries=5', ID='1002', Name='Diana', Age='30' Error: Configuration error: Invalid timeout value: invalid Processing: Config='username=eve,timeout=30,max_retries=5', ID='invalid_id', Name='Eve', Age='22' Error: Parse error: invalid digit found in string Processing: Config='username=frank,timeout=30,max_retries=5', ID='1004', Name='F', Age='17' Error: Validation error: Name too short, minimum length is 2 characters","title":"Expected Output"},{"location":"module3-data-types/exercises/02_error_handling/#tips","text":"Use match expressions to handle Option and Result types Remember that the Display trait is used to format error messages for end users The ? operator can be used to automatically propagate errors in functions that return Result Use the parse method to convert strings to numbers, which returns a Result The From trait is used for automatic conversions between error types when using the ? operator","title":"Tips"},{"location":"module4-code-organization/","text":"Module 4: Code Organization Core Module Learning Objectives Understand how to organize Rust code using packages, crates, and modules Learn the visibility rules in Rust Master the use of paths for referring to items in the module tree Structure code for maintainability and reusability Content Summary This module covers Rust's code organization concepts, teaching you how to structure your code using packages, crates, and modules. You'll learn how to control item visibility and how to use paths to refer to items in the module tree, making your code more maintainable and reusable. Topics Covered Packages and Crates Understanding the relationship between packages and crates Creating and managing a package with Cargo Binary crates vs. library crates Modules Defining modules and their hierarchy Module visibility rules The pub keyword and exposing APIs Paths Referring to items in the module tree Absolute vs. relative paths The use keyword for bringing paths into scope Re-exporting names with pub use Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Module Explorer - Create a multi-module project with proper organization Resources The Rust Programming Language Book - Chapter 7 Rust By Example - Modules Rust API Guidelines","title":"Overview"},{"location":"module4-code-organization/#module-4-code-organization","text":"","title":"Module 4: Code Organization"},{"location":"module4-code-organization/#core-module","text":"","title":"Core Module"},{"location":"module4-code-organization/#learning-objectives","text":"Understand how to organize Rust code using packages, crates, and modules Learn the visibility rules in Rust Master the use of paths for referring to items in the module tree Structure code for maintainability and reusability","title":"Learning Objectives"},{"location":"module4-code-organization/#content-summary","text":"This module covers Rust's code organization concepts, teaching you how to structure your code using packages, crates, and modules. You'll learn how to control item visibility and how to use paths to refer to items in the module tree, making your code more maintainable and reusable.","title":"Content Summary"},{"location":"module4-code-organization/#topics-covered","text":"Packages and Crates Understanding the relationship between packages and crates Creating and managing a package with Cargo Binary crates vs. library crates Modules Defining modules and their hierarchy Module visibility rules The pub keyword and exposing APIs Paths Referring to items in the module tree Absolute vs. relative paths The use keyword for bringing paths into scope Re-exporting names with pub use","title":"Topics Covered"},{"location":"module4-code-organization/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Module Explorer - Create a multi-module project with proper organization","title":"Exercises"},{"location":"module4-code-organization/#resources","text":"The Rust Programming Language Book - Chapter 7 Rust By Example - Modules Rust API Guidelines","title":"Resources"},{"location":"module4-code-organization/exercises/01_module_explorer/","text":"Exercise 1: Module Explorer Problem Statement Create a multi-module Rust project that models a simple e-commerce system with proper code organization. The project should include modules for products, users, orders, and inventory management. Learning Objectives Practice organizing code using modules and submodules Implement proper visibility controls using pub and pub(crate) Use the use statement to bring items into scope Create a clean API between modules Starter Code // src/main.rs or lib.rs // TODO: Define your module structure here // Hint: You'll need to create modules for products, users, orders, and inventory fn main() { // TODO: Use your modules to create a simple e-commerce workflow: // 1. Create some products // 2. Add products to inventory // 3. Create a user // 4. Create an order for the user with some products // 5. Print order details } How to Run Your Code First, modify the starter code in 01_module_explorer_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module4_01 Expected Structure Your project should have a module structure similar to this: src/ \u251c\u2500\u2500 main.rs (or lib.rs) \u251c\u2500\u2500 product.rs \u251c\u2500\u2500 user.rs \u251c\u2500\u2500 order.rs \u2514\u2500\u2500 inventory.rs Each module should define appropriate types and functions with proper visibility modifiers. Requirements Product Module Define a Product struct with fields for id, name, price, and description Implement methods for creating and displaying products User Module Define a User struct with fields for id, name, email, and address Implement methods for creating and displaying users Order Module Define an Order struct that associates users with purchased products Include order status using an enum Implement methods for creating, updating, and displaying orders Inventory Module Define functions to add, remove, and check stock of products Track product quantities Tips Think carefully about which items should be public and which should be private Consider using submodules for related functionality Remember that you can use pub(crate) to restrict visibility to the current crate Use proper paths when referring to items in other modules","title":"Module Explorer"},{"location":"module4-code-organization/exercises/01_module_explorer/#exercise-1-module-explorer","text":"","title":"Exercise 1: Module Explorer"},{"location":"module4-code-organization/exercises/01_module_explorer/#problem-statement","text":"Create a multi-module Rust project that models a simple e-commerce system with proper code organization. The project should include modules for products, users, orders, and inventory management.","title":"Problem Statement"},{"location":"module4-code-organization/exercises/01_module_explorer/#learning-objectives","text":"Practice organizing code using modules and submodules Implement proper visibility controls using pub and pub(crate) Use the use statement to bring items into scope Create a clean API between modules","title":"Learning Objectives"},{"location":"module4-code-organization/exercises/01_module_explorer/#starter-code","text":"// src/main.rs or lib.rs // TODO: Define your module structure here // Hint: You'll need to create modules for products, users, orders, and inventory fn main() { // TODO: Use your modules to create a simple e-commerce workflow: // 1. Create some products // 2. Add products to inventory // 3. Create a user // 4. Create an order for the user with some products // 5. Print order details }","title":"Starter Code"},{"location":"module4-code-organization/exercises/01_module_explorer/#how-to-run-your-code","text":"First, modify the starter code in 01_module_explorer_starter.rs to fix the ownership issues Run your code from the bootcamp root directory with: cargo run --bin module4_01","title":"How to Run Your Code"},{"location":"module4-code-organization/exercises/01_module_explorer/#expected-structure","text":"Your project should have a module structure similar to this: src/ \u251c\u2500\u2500 main.rs (or lib.rs) \u251c\u2500\u2500 product.rs \u251c\u2500\u2500 user.rs \u251c\u2500\u2500 order.rs \u2514\u2500\u2500 inventory.rs Each module should define appropriate types and functions with proper visibility modifiers.","title":"Expected Structure"},{"location":"module4-code-organization/exercises/01_module_explorer/#requirements","text":"Product Module Define a Product struct with fields for id, name, price, and description Implement methods for creating and displaying products User Module Define a User struct with fields for id, name, email, and address Implement methods for creating and displaying users Order Module Define an Order struct that associates users with purchased products Include order status using an enum Implement methods for creating, updating, and displaying orders Inventory Module Define functions to add, remove, and check stock of products Track product quantities","title":"Requirements"},{"location":"module4-code-organization/exercises/01_module_explorer/#tips","text":"Think carefully about which items should be public and which should be private Consider using submodules for related functionality Remember that you can use pub(crate) to restrict visibility to the current crate Use proper paths when referring to items in other modules","title":"Tips"},{"location":"module5-collections/","text":"Module 5: Collections Core Module Learning Objectives Master Rust's common collection types (vectors, strings, hash maps) Learn how to efficiently store, access, and modify collections of data Understand ownership and borrowing in the context of collections Apply collections to solve real-world problems Content Summary This module covers Rust's standard collection types, which are essential for storing and manipulating groups of data. You'll learn the characteristics, performance implications, and best practices for using vectors, strings, and hash maps in your Rust programs. Topics Covered Vectors Creating and updating vectors Reading elements from vectors Iterating over vectors Using different types in vectors with enums Strings String vs. &str Creating and manipulating strings UTF-8 encoding and considerations String operations and methods Hash Maps Creating and updating hash maps Accessing values in hash maps Iterating over hash maps Common hash map patterns Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Collection Manipulation - Practice working with vectors, strings, and hash maps Final Challenge After completing this module, you're ready to tackle the Rust Mini-Project Challenge - a comprehensive exercise that combines concepts from all core modules. Resources The Rust Programming Language Book - Chapter 8 Rust By Example - Collections Rust Standard Library Documentation - Collections","title":"Overview"},{"location":"module5-collections/#module-5-collections","text":"","title":"Module 5: Collections"},{"location":"module5-collections/#core-module","text":"","title":"Core Module"},{"location":"module5-collections/#learning-objectives","text":"Master Rust's common collection types (vectors, strings, hash maps) Learn how to efficiently store, access, and modify collections of data Understand ownership and borrowing in the context of collections Apply collections to solve real-world problems","title":"Learning Objectives"},{"location":"module5-collections/#content-summary","text":"This module covers Rust's standard collection types, which are essential for storing and manipulating groups of data. You'll learn the characteristics, performance implications, and best practices for using vectors, strings, and hash maps in your Rust programs.","title":"Content Summary"},{"location":"module5-collections/#topics-covered","text":"Vectors Creating and updating vectors Reading elements from vectors Iterating over vectors Using different types in vectors with enums Strings String vs. &str Creating and manipulating strings UTF-8 encoding and considerations String operations and methods Hash Maps Creating and updating hash maps Accessing values in hash maps Iterating over hash maps Common hash map patterns","title":"Topics Covered"},{"location":"module5-collections/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Collection Manipulation - Practice working with vectors, strings, and hash maps","title":"Exercises"},{"location":"module5-collections/#final-challenge","text":"After completing this module, you're ready to tackle the Rust Mini-Project Challenge - a comprehensive exercise that combines concepts from all core modules.","title":"Final Challenge"},{"location":"module5-collections/#resources","text":"The Rust Programming Language Book - Chapter 8 Rust By Example - Collections Rust Standard Library Documentation - Collections","title":"Resources"},{"location":"module5-collections/exercises/01_collection_manipulation/","text":"Exercise 1: Collection Manipulation Problem Statement Implement a program that demonstrates effective use of Rust's common collection types (vectors, strings, and hash maps) to process and analyze text data. Learning Objectives Practice working with vectors, strings, and hash maps Understand how to efficiently manipulate and transform collections Apply iterators and collection methods to solve problems Handle string data properly in Rust Starter Code use std::collections::HashMap; fn main() { // Sample text for analysis let text = \"Rust is a multi-paradigm, general-purpose programming language. \\ Rust emphasizes performance, type safety, and concurrency. \\ Rust enforces memory safety\u2014that is, that all references point \\ to valid memory\u2014without requiring the use of a garbage collector \\ or reference counting present in other memory-safe languages.\"; // TODO: 1. Split the text into words and store them in a vector let words = vec![]; // TODO: 2. Count the frequency of each word and store in a HashMap let word_counts = HashMap::new(); // TODO: 3. Find the longest word in the text let longest_word = \"\"; // TODO: 4. Convert all words to uppercase and store in a new vector let uppercase_words = vec![]; // TODO: 5. Filter out words shorter than 4 characters let filtered_words = vec![]; // Print results println!(\"Word counts: {:?}\", word_counts); println!(\"Longest word: {}\", longest_word); println!(\"Uppercase words: {:?}\", uppercase_words); println!(\"Words longer than 3 characters: {:?}\", filtered_words); } How to Run Your Code First, modify the starter code in 01_library_system_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_01 Expected Output Your output should be similar to (word counts might vary depending on how you split words): Word counts: {\"Rust\": 3, \"a\": 2, \"memory-safe\": 1, \"performance\": 1, ...} Longest word: \"multi-paradigm,\" Uppercase words: [\"RUST\", \"IS\", \"A\", \"MULTI-PARADIGM,\", ...] Words longer than 3 characters: [\"Rust\", \"multi-paradigm\", \"general-purpose\", ...] Tips Use string methods like split_whitespace() or split() to separate words Remember to handle punctuation appropriately Consider using to_string() or String::from() to convert string slices to owned strings Utilize collection methods like iter() , map() , filter() , and collect() Use the entry() API for efficient insertion into hash maps","title":"Collection Manipulation"},{"location":"module5-collections/exercises/01_collection_manipulation/#exercise-1-collection-manipulation","text":"","title":"Exercise 1: Collection Manipulation"},{"location":"module5-collections/exercises/01_collection_manipulation/#problem-statement","text":"Implement a program that demonstrates effective use of Rust's common collection types (vectors, strings, and hash maps) to process and analyze text data.","title":"Problem Statement"},{"location":"module5-collections/exercises/01_collection_manipulation/#learning-objectives","text":"Practice working with vectors, strings, and hash maps Understand how to efficiently manipulate and transform collections Apply iterators and collection methods to solve problems Handle string data properly in Rust","title":"Learning Objectives"},{"location":"module5-collections/exercises/01_collection_manipulation/#starter-code","text":"use std::collections::HashMap; fn main() { // Sample text for analysis let text = \"Rust is a multi-paradigm, general-purpose programming language. \\ Rust emphasizes performance, type safety, and concurrency. \\ Rust enforces memory safety\u2014that is, that all references point \\ to valid memory\u2014without requiring the use of a garbage collector \\ or reference counting present in other memory-safe languages.\"; // TODO: 1. Split the text into words and store them in a vector let words = vec![]; // TODO: 2. Count the frequency of each word and store in a HashMap let word_counts = HashMap::new(); // TODO: 3. Find the longest word in the text let longest_word = \"\"; // TODO: 4. Convert all words to uppercase and store in a new vector let uppercase_words = vec![]; // TODO: 5. Filter out words shorter than 4 characters let filtered_words = vec![]; // Print results println!(\"Word counts: {:?}\", word_counts); println!(\"Longest word: {}\", longest_word); println!(\"Uppercase words: {:?}\", uppercase_words); println!(\"Words longer than 3 characters: {:?}\", filtered_words); }","title":"Starter Code"},{"location":"module5-collections/exercises/01_collection_manipulation/#how-to-run-your-code","text":"First, modify the starter code in 01_library_system_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module3_01","title":"How to Run Your Code"},{"location":"module5-collections/exercises/01_collection_manipulation/#expected-output","text":"Your output should be similar to (word counts might vary depending on how you split words): Word counts: {\"Rust\": 3, \"a\": 2, \"memory-safe\": 1, \"performance\": 1, ...} Longest word: \"multi-paradigm,\" Uppercase words: [\"RUST\", \"IS\", \"A\", \"MULTI-PARADIGM,\", ...] Words longer than 3 characters: [\"Rust\", \"multi-paradigm\", \"general-purpose\", ...]","title":"Expected Output"},{"location":"module5-collections/exercises/01_collection_manipulation/#tips","text":"Use string methods like split_whitespace() or split() to separate words Remember to handle punctuation appropriately Consider using to_string() or String::from() to convert string slices to owned strings Utilize collection methods like iter() , map() , filter() , and collect() Use the entry() API for efficient insertion into hash maps","title":"Tips"},{"location":"module5-collections/exercises/final_challenge/","text":"Final Challenge: Rust Task Manager Challenge Overview Now that you've completed the core modules of the Rust bootcamp, it's time to put your skills to the test with a comprehensive challenge. In this project, you'll build a command-line task management application that incorporates concepts from all the core modules. Learning Objectives Apply Rust fundamentals in a practical project Combine multiple concepts including ownership, structs, enums, modules, and collections Gain experience with building a complete, usable application Practice error handling and user input processing Requirements Core Functionality Your task manager application should be able to: Add tasks with a title, description, and optional due date List all tasks with their details and status Mark tasks as complete Delete tasks Save tasks to a file and load tasks from a file Filter tasks by status (pending/completed) and due date Technical Requirements Data Modeling (Module 3) Define appropriate structs and enums for tasks and their properties Implement methods for task manipulation Use enums for task status and command types Memory Management (Module 2) Apply appropriate ownership and borrowing patterns Avoid unnecessary cloning and copies Clean up resources properly Code Organization (Module 4) Organize code into modules (e.g., task management, file I/O, user interface) Apply visibility rules appropriately Create a clean API between modules Collections (Module 5) Store tasks in appropriate collection types Filter and sort tasks efficiently Handle string manipulation for user input and output Error Handling Use Result and Option types for error handling Provide meaningful error messages to users Handle file I/O errors gracefully Starter Code // This is a minimal starter structure - feel free to modify as needed! // Task status enum enum TaskStatus { Pending, Completed, } // Task struct to store task information struct Task { id: u32, title: String, description: String, due_date: Option<String>, // Consider using a proper date type in your implementation status: TaskStatus, } // TaskManager to handle operations on tasks struct TaskManager { tasks: Vec<Task>, next_id: u32, } impl TaskManager { // Create a new TaskManager fn new() -> TaskManager { TaskManager { tasks: Vec::new(), next_id: 1, } } // Add the rest of the implementation... } // Command enum to represent user commands enum Command { Add { title: String, description: String, due_date: Option<String> }, List, Complete { id: u32 }, Delete { id: u32 }, Save { filename: String }, Load { filename: String }, Quit, Unknown, } fn main() { // Initialize task manager let mut task_manager = TaskManager::new(); // Main application loop loop { // Get user command // Process command // Exit if command is Quit } } Extension Ideas Once you have the basic functionality working, consider adding these features: Task Categories or Tags : Allow users to categorize tasks and filter by category Priority Levels : Add priority levels to tasks and sort by priority Recurring Tasks : Implement support for tasks that repeat at regular intervals Better Date Handling : Use a proper date/time crate like chrono for due dates Interactive UI : Improve the command-line interface with colored text or a TUI library Submission Requirements Your final project should include: Well-organized, commented Rust code A README.md explaining how to build and use your application Example input and output showing your application in action Tips Start with a simple implementation and add features incrementally Test your code frequently as you develop Consider edge cases like empty task lists and invalid user input Focus on creating a good user experience with clear instructions and feedback Good luck, and have fun applying your Rust knowledge to create a useful application!","title":"Final Challenge"},{"location":"module5-collections/exercises/final_challenge/#final-challenge-rust-task-manager","text":"","title":"Final Challenge: Rust Task Manager"},{"location":"module5-collections/exercises/final_challenge/#challenge-overview","text":"Now that you've completed the core modules of the Rust bootcamp, it's time to put your skills to the test with a comprehensive challenge. In this project, you'll build a command-line task management application that incorporates concepts from all the core modules.","title":"Challenge Overview"},{"location":"module5-collections/exercises/final_challenge/#learning-objectives","text":"Apply Rust fundamentals in a practical project Combine multiple concepts including ownership, structs, enums, modules, and collections Gain experience with building a complete, usable application Practice error handling and user input processing","title":"Learning Objectives"},{"location":"module5-collections/exercises/final_challenge/#requirements","text":"","title":"Requirements"},{"location":"module5-collections/exercises/final_challenge/#core-functionality","text":"Your task manager application should be able to: Add tasks with a title, description, and optional due date List all tasks with their details and status Mark tasks as complete Delete tasks Save tasks to a file and load tasks from a file Filter tasks by status (pending/completed) and due date","title":"Core Functionality"},{"location":"module5-collections/exercises/final_challenge/#technical-requirements","text":"Data Modeling (Module 3) Define appropriate structs and enums for tasks and their properties Implement methods for task manipulation Use enums for task status and command types Memory Management (Module 2) Apply appropriate ownership and borrowing patterns Avoid unnecessary cloning and copies Clean up resources properly Code Organization (Module 4) Organize code into modules (e.g., task management, file I/O, user interface) Apply visibility rules appropriately Create a clean API between modules Collections (Module 5) Store tasks in appropriate collection types Filter and sort tasks efficiently Handle string manipulation for user input and output Error Handling Use Result and Option types for error handling Provide meaningful error messages to users Handle file I/O errors gracefully","title":"Technical Requirements"},{"location":"module5-collections/exercises/final_challenge/#starter-code","text":"// This is a minimal starter structure - feel free to modify as needed! // Task status enum enum TaskStatus { Pending, Completed, } // Task struct to store task information struct Task { id: u32, title: String, description: String, due_date: Option<String>, // Consider using a proper date type in your implementation status: TaskStatus, } // TaskManager to handle operations on tasks struct TaskManager { tasks: Vec<Task>, next_id: u32, } impl TaskManager { // Create a new TaskManager fn new() -> TaskManager { TaskManager { tasks: Vec::new(), next_id: 1, } } // Add the rest of the implementation... } // Command enum to represent user commands enum Command { Add { title: String, description: String, due_date: Option<String> }, List, Complete { id: u32 }, Delete { id: u32 }, Save { filename: String }, Load { filename: String }, Quit, Unknown, } fn main() { // Initialize task manager let mut task_manager = TaskManager::new(); // Main application loop loop { // Get user command // Process command // Exit if command is Quit } }","title":"Starter Code"},{"location":"module5-collections/exercises/final_challenge/#extension-ideas","text":"Once you have the basic functionality working, consider adding these features: Task Categories or Tags : Allow users to categorize tasks and filter by category Priority Levels : Add priority levels to tasks and sort by priority Recurring Tasks : Implement support for tasks that repeat at regular intervals Better Date Handling : Use a proper date/time crate like chrono for due dates Interactive UI : Improve the command-line interface with colored text or a TUI library","title":"Extension Ideas"},{"location":"module5-collections/exercises/final_challenge/#submission-requirements","text":"Your final project should include: Well-organized, commented Rust code A README.md explaining how to build and use your application Example input and output showing your application in action","title":"Submission Requirements"},{"location":"module5-collections/exercises/final_challenge/#tips","text":"Start with a simple implementation and add features incrementally Test your code frequently as you develop Consider edge cases like empty task lists and invalid user input Focus on creating a good user experience with clear instructions and feedback Good luck, and have fun applying your Rust knowledge to create a useful application!","title":"Tips"},{"location":"module6-advanced-concepts/","text":"Module 6: Advanced Concepts Optional Module Learning Objectives Understand and implement traits in Rust Master Rust's error handling mechanisms Learn how to write and run tests in Rust Build command-line applications with Rust Content Summary This module covers advanced Rust concepts including traits, error handling, testing, and CLI development. These topics will help you write more sophisticated, robust, and user-friendly Rust applications. Topics Covered Traits Defining and implementing traits Default implementations Trait bounds and trait objects The most common standard library traits Error Handling The panic! macro and when to use it Recoverable errors with Result<T, E> Propagating errors with the ? operator Creating custom error types Testing Writing unit tests Test organization and conventions Using assertions Integration tests CLI Applications Parsing command-line arguments Using CLI libraries like clap or structopt Reading from and writing to the terminal Exit codes and error reporting Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Trait Workshop - Implement and use traits to create flexible interfaces Resources The Rust Programming Language Book - Chapters 10, 9, 11 Rust By Example - Traits, Error Handling, Testing Command Line Applications in Rust","title":"Overview"},{"location":"module6-advanced-concepts/#module-6-advanced-concepts","text":"","title":"Module 6: Advanced Concepts"},{"location":"module6-advanced-concepts/#optional-module","text":"","title":"Optional Module"},{"location":"module6-advanced-concepts/#learning-objectives","text":"Understand and implement traits in Rust Master Rust's error handling mechanisms Learn how to write and run tests in Rust Build command-line applications with Rust","title":"Learning Objectives"},{"location":"module6-advanced-concepts/#content-summary","text":"This module covers advanced Rust concepts including traits, error handling, testing, and CLI development. These topics will help you write more sophisticated, robust, and user-friendly Rust applications.","title":"Content Summary"},{"location":"module6-advanced-concepts/#topics-covered","text":"Traits Defining and implementing traits Default implementations Trait bounds and trait objects The most common standard library traits Error Handling The panic! macro and when to use it Recoverable errors with Result<T, E> Propagating errors with the ? operator Creating custom error types Testing Writing unit tests Test organization and conventions Using assertions Integration tests CLI Applications Parsing command-line arguments Using CLI libraries like clap or structopt Reading from and writing to the terminal Exit codes and error reporting","title":"Topics Covered"},{"location":"module6-advanced-concepts/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Trait Workshop - Implement and use traits to create flexible interfaces","title":"Exercises"},{"location":"module6-advanced-concepts/#resources","text":"The Rust Programming Language Book - Chapters 10, 9, 11 Rust By Example - Traits, Error Handling, Testing Command Line Applications in Rust","title":"Resources"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/","text":"Exercise 1: Trait Workshop Problem Statement Design and implement a shape calculation system using traits. The system should be able to calculate area and perimeter for different geometric shapes, including circles, rectangles, and triangles. Learning Objectives Practice defining and implementing traits Use trait bounds to create flexible interfaces Implement default trait methods Work with trait objects for runtime polymorphism Starter Code use std::f64::consts::PI; // Define the Shape trait with methods for area and perimeter calculation trait Shape { fn area(&self) -> f64; fn perimeter(&self) -> f64; // Default method to return the shape's name fn name(&self) -> &str { \"Unknown Shape\" } } // Implement Circle struct Circle { radius: f64, } impl Circle { fn new(radius: f64) -> Self { Self { radius } } } impl Shape for Circle { // TODO: Implement area method for Circle fn area(&self) -> f64 { // Hint: The area of a circle is PI * r\u00b2 0.0 // Replace with correct implementation } // TODO: Implement perimeter method for Circle fn perimeter(&self) -> f64 { // Hint: The perimeter (circumference) of a circle is 2 * PI * r 0.0 // Replace with correct implementation } // TODO: Override the name method to return \"Circle\" fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Rectangle struct Rectangle { width: f64, height: f64, } impl Rectangle { fn new(width: f64, height: f64) -> Self { Self { width, height } } } // TODO: Implement the Shape trait for Rectangle impl Shape for Rectangle { // Implement area method fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Triangle struct Triangle { side_a: f64, side_b: f64, side_c: f64, } impl Triangle { // Constructor that validates if the sides can form a valid triangle fn new(side_a: f64, side_b: f64, side_c: f64) -> Option<Self> { // TODO: Check if the sides can form a valid triangle // Hint: In a valid triangle, the sum of any two sides must be greater than the third side Some(Self { side_a, side_b, side_c }) // Replace with validation logic } } // TODO: Implement the Shape trait for Triangle impl Shape for Triangle { // Implement area method // Hint: You can use Heron's formula: // Let s = (a + b + c) / 2 // Area = \u221a(s * (s - a) * (s - b) * (s - c)) fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Function to print shape information using trait bounds fn print_shape_info<T: Shape>(shape: &T) { // TODO: Implement this function to print the shape's name, area, and perimeter println!(\"Shape: {}\", shape.name()); println!(\"Area: {:.2}\", shape.area()); println!(\"Perimeter: {:.2}\", shape.perimeter()); println!(); } fn main() { // Create instances of each shape let circle = Circle::new(5.0); // TODO: Create a rectangle with width 3.0 and height 5.0 // TODO: Create a triangle with sides 3.0, 4.0, and 5.0 // Remember to handle the Option return type // TODO: Print information for each shape using print_shape_info print_shape_info(&circle); // Add calls for rectangle and triangle // TODO: Store shapes in a vector of trait objects and iterate through them // Hint: You'll need to use Box<dyn Shape> to store different shapes in the same vector let shapes: Vec<Box<dyn Shape>> = vec![ Box::new(circle), // Add the rectangle and triangle to this vector ]; println!(\"Shapes in collection:\"); // TODO: Iterate through shapes and print information for each // Bonus: Calculate the total area of all shapes // TODO: Use iterator methods to sum the areas of all shapes } How to Run Your Code First, modify the starter code in 01_trait_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module6_01 Expected Output Your output should be similar to: Shape: Circle Area: 78.54 Perimeter: 31.42 Shape: Rectangle Area: 15.00 Perimeter: 16.00 Shape: Triangle Area: 6.00 Perimeter: 12.00 Shapes in collection: Circle - Area: 78.54, Perimeter: 31.42 Rectangle - Area: 15.00, Perimeter: 16.00 Triangle - Area: 6.00, Perimeter: 12.00 Tips Use the f64 type for floating-point calculations Remember to implement the trait for each shape type Consider adding a constructor method ( new ) for each shape For the triangle, you can use Heron's formula to calculate the area Round the output to 2 decimal places for clarity Use Box<dyn Shape> to create a collection of trait objects","title":"Trait Workshop"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#exercise-1-trait-workshop","text":"","title":"Exercise 1: Trait Workshop"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#problem-statement","text":"Design and implement a shape calculation system using traits. The system should be able to calculate area and perimeter for different geometric shapes, including circles, rectangles, and triangles.","title":"Problem Statement"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#learning-objectives","text":"Practice defining and implementing traits Use trait bounds to create flexible interfaces Implement default trait methods Work with trait objects for runtime polymorphism","title":"Learning Objectives"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#starter-code","text":"use std::f64::consts::PI; // Define the Shape trait with methods for area and perimeter calculation trait Shape { fn area(&self) -> f64; fn perimeter(&self) -> f64; // Default method to return the shape's name fn name(&self) -> &str { \"Unknown Shape\" } } // Implement Circle struct Circle { radius: f64, } impl Circle { fn new(radius: f64) -> Self { Self { radius } } } impl Shape for Circle { // TODO: Implement area method for Circle fn area(&self) -> f64 { // Hint: The area of a circle is PI * r\u00b2 0.0 // Replace with correct implementation } // TODO: Implement perimeter method for Circle fn perimeter(&self) -> f64 { // Hint: The perimeter (circumference) of a circle is 2 * PI * r 0.0 // Replace with correct implementation } // TODO: Override the name method to return \"Circle\" fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Rectangle struct Rectangle { width: f64, height: f64, } impl Rectangle { fn new(width: f64, height: f64) -> Self { Self { width, height } } } // TODO: Implement the Shape trait for Rectangle impl Shape for Rectangle { // Implement area method fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Implement Triangle struct Triangle { side_a: f64, side_b: f64, side_c: f64, } impl Triangle { // Constructor that validates if the sides can form a valid triangle fn new(side_a: f64, side_b: f64, side_c: f64) -> Option<Self> { // TODO: Check if the sides can form a valid triangle // Hint: In a valid triangle, the sum of any two sides must be greater than the third side Some(Self { side_a, side_b, side_c }) // Replace with validation logic } } // TODO: Implement the Shape trait for Triangle impl Shape for Triangle { // Implement area method // Hint: You can use Heron's formula: // Let s = (a + b + c) / 2 // Area = \u221a(s * (s - a) * (s - b) * (s - c)) fn area(&self) -> f64 { 0.0 // Replace with correct implementation } // Implement perimeter method fn perimeter(&self) -> f64 { 0.0 // Replace with correct implementation } // Override name method fn name(&self) -> &str { \"Unknown Shape\" // Replace with correct implementation } } // Function to print shape information using trait bounds fn print_shape_info<T: Shape>(shape: &T) { // TODO: Implement this function to print the shape's name, area, and perimeter println!(\"Shape: {}\", shape.name()); println!(\"Area: {:.2}\", shape.area()); println!(\"Perimeter: {:.2}\", shape.perimeter()); println!(); } fn main() { // Create instances of each shape let circle = Circle::new(5.0); // TODO: Create a rectangle with width 3.0 and height 5.0 // TODO: Create a triangle with sides 3.0, 4.0, and 5.0 // Remember to handle the Option return type // TODO: Print information for each shape using print_shape_info print_shape_info(&circle); // Add calls for rectangle and triangle // TODO: Store shapes in a vector of trait objects and iterate through them // Hint: You'll need to use Box<dyn Shape> to store different shapes in the same vector let shapes: Vec<Box<dyn Shape>> = vec![ Box::new(circle), // Add the rectangle and triangle to this vector ]; println!(\"Shapes in collection:\"); // TODO: Iterate through shapes and print information for each // Bonus: Calculate the total area of all shapes // TODO: Use iterator methods to sum the areas of all shapes }","title":"Starter Code"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#how-to-run-your-code","text":"First, modify the starter code in 01_trait_workshop_starter.rs according to the requirements Run your code from the bootcamp root directory with: cargo run --bin module6_01","title":"How to Run Your Code"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#expected-output","text":"Your output should be similar to: Shape: Circle Area: 78.54 Perimeter: 31.42 Shape: Rectangle Area: 15.00 Perimeter: 16.00 Shape: Triangle Area: 6.00 Perimeter: 12.00 Shapes in collection: Circle - Area: 78.54, Perimeter: 31.42 Rectangle - Area: 15.00, Perimeter: 16.00 Triangle - Area: 6.00, Perimeter: 12.00","title":"Expected Output"},{"location":"module6-advanced-concepts/exercises/01_trait_workshop/#tips","text":"Use the f64 type for floating-point calculations Remember to implement the trait for each shape type Consider adding a constructor method ( new ) for each shape For the triangle, you can use Heron's formula to calculate the area Round the output to 2 decimal places for clarity Use Box<dyn Shape> to create a collection of trait objects","title":"Tips"},{"location":"module7-icp-integration/","text":"Module 7: ICP Integration Core Module Learning Objectives Understand the Internet Computer Protocol (ICP) and its architecture Learn how to develop canister smart contracts using Rust Master the integration of Rust with the Internet Computer Build and deploy decentralized applications on the Internet Computer Content Summary This module introduces you to developing for the Internet Computer Protocol using Rust. You'll learn how the Internet Computer works, how to write canister smart contracts in Rust, and how to deploy your applications to the ICP network. Topics Covered Introduction to the Internet Computer Understanding the Internet Computer architecture Canisters and the actor model Orthogonal persistence Cycles and resource management Rust for Internet Computer Development The ic-cdk and related libraries Actor model implementation in Rust Asynchronous programming in canisters Thread local storage and state management Building Smart Contracts Defining canister interfaces Implementing query and update methods Inter-canister calls Working with stable memory Deployment and Testing Local development with DFINITY SDK Testing canister smart contracts Deploying to the IC network Interacting with deployed canisters Exercises In the exercises directory, you'll find practice problems to reinforce these concepts: Hello ICP - Create and deploy a simple greeting canister State Management - Build a canister that maintains state across upgrades Multi-Canister App - Develop a simple application using multiple communicating canisters Resources Internet Computer Documentation Rust CDK Documentation Rust Canister Development Guide Examples of Rust Canisters","title":"Overview"},{"location":"module7-icp-integration/#module-7-icp-integration","text":"","title":"Module 7: ICP Integration"},{"location":"module7-icp-integration/#core-module","text":"","title":"Core Module"},{"location":"module7-icp-integration/#learning-objectives","text":"Understand the Internet Computer Protocol (ICP) and its architecture Learn how to develop canister smart contracts using Rust Master the integration of Rust with the Internet Computer Build and deploy decentralized applications on the Internet Computer","title":"Learning Objectives"},{"location":"module7-icp-integration/#content-summary","text":"This module introduces you to developing for the Internet Computer Protocol using Rust. You'll learn how the Internet Computer works, how to write canister smart contracts in Rust, and how to deploy your applications to the ICP network.","title":"Content Summary"},{"location":"module7-icp-integration/#topics-covered","text":"Introduction to the Internet Computer Understanding the Internet Computer architecture Canisters and the actor model Orthogonal persistence Cycles and resource management Rust for Internet Computer Development The ic-cdk and related libraries Actor model implementation in Rust Asynchronous programming in canisters Thread local storage and state management Building Smart Contracts Defining canister interfaces Implementing query and update methods Inter-canister calls Working with stable memory Deployment and Testing Local development with DFINITY SDK Testing canister smart contracts Deploying to the IC network Interacting with deployed canisters","title":"Topics Covered"},{"location":"module7-icp-integration/#exercises","text":"In the exercises directory, you'll find practice problems to reinforce these concepts: Hello ICP - Create and deploy a simple greeting canister State Management - Build a canister that maintains state across upgrades Multi-Canister App - Develop a simple application using multiple communicating canisters","title":"Exercises"},{"location":"module7-icp-integration/#resources","text":"Internet Computer Documentation Rust CDK Documentation Rust Canister Development Guide Examples of Rust Canisters","title":"Resources"},{"location":"module7-icp-integration/exercises/01_hello_icp/","text":"Exercise 1: Hello ICP Problem Statement Create a simple greeting canister that runs on the Internet Computer. The canister should store a greeting message and allow users to update and retrieve it. Learning Objectives Set up a basic Rust canister project for the Internet Computer Understand canister state management in Rust Implement query and update methods Test and deploy a canister locally Prerequisites DFX SDK installed Rust and Cargo installed Starter Code use ic_cdk::export::{ candid::{CandidType, Deserialize}, Principal, }; use ic_cdk_macros::*; use std::cell::RefCell; // TODO: Define a struct to hold the greeting message // TODO: Create a thread-local variable to store the state #[init] fn init() { // TODO: Initialize the canister state with a default greeting } #[update] fn update_greeting(new_greeting: String) -> String { // TODO: Update the greeting and return the new greeting } #[query] fn get_greeting() -> String { // TODO: Return the current greeting } // Additional challenge: Add a method to get the greeting history Expected Project Structure hello_icp/ \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 dfx.json \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.rs (containing the canister code) \u2514\u2500\u2500 README.md Steps to Complete Create a new project using the DFX command: dfx new hello_icp --type=rust Implement the canister code using the starter code above Configure your dfx.json to include the Rust canister Deploy and test locally: dfx start --background dfx deploy dfx canister call hello_icp get_greeting dfx canister call hello_icp update_greeting '(\"Hello, Internet Computer!\")' Expected Results The canister should store a greeting message (default: \"Hello, World!\") Users should be able to update the greeting with a new message Users should be able to query the current greeting Tips Use thread_local! to create state that persists between canister calls Remember that all update methods should modify the state through a mutable reference Test your canister locally before deploying to the IC mainnet Use the Candid UI to interact with your canister during testing For the additional challenge, consider using a Vec<String> to store the greeting history","title":"Hello ICP"},{"location":"module7-icp-integration/exercises/01_hello_icp/#exercise-1-hello-icp","text":"","title":"Exercise 1: Hello ICP"},{"location":"module7-icp-integration/exercises/01_hello_icp/#problem-statement","text":"Create a simple greeting canister that runs on the Internet Computer. The canister should store a greeting message and allow users to update and retrieve it.","title":"Problem Statement"},{"location":"module7-icp-integration/exercises/01_hello_icp/#learning-objectives","text":"Set up a basic Rust canister project for the Internet Computer Understand canister state management in Rust Implement query and update methods Test and deploy a canister locally","title":"Learning Objectives"},{"location":"module7-icp-integration/exercises/01_hello_icp/#prerequisites","text":"DFX SDK installed Rust and Cargo installed","title":"Prerequisites"},{"location":"module7-icp-integration/exercises/01_hello_icp/#starter-code","text":"use ic_cdk::export::{ candid::{CandidType, Deserialize}, Principal, }; use ic_cdk_macros::*; use std::cell::RefCell; // TODO: Define a struct to hold the greeting message // TODO: Create a thread-local variable to store the state #[init] fn init() { // TODO: Initialize the canister state with a default greeting } #[update] fn update_greeting(new_greeting: String) -> String { // TODO: Update the greeting and return the new greeting } #[query] fn get_greeting() -> String { // TODO: Return the current greeting } // Additional challenge: Add a method to get the greeting history","title":"Starter Code"},{"location":"module7-icp-integration/exercises/01_hello_icp/#expected-project-structure","text":"hello_icp/ \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 dfx.json \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 lib.rs (containing the canister code) \u2514\u2500\u2500 README.md","title":"Expected Project Structure"},{"location":"module7-icp-integration/exercises/01_hello_icp/#steps-to-complete","text":"Create a new project using the DFX command: dfx new hello_icp --type=rust Implement the canister code using the starter code above Configure your dfx.json to include the Rust canister Deploy and test locally: dfx start --background dfx deploy dfx canister call hello_icp get_greeting dfx canister call hello_icp update_greeting '(\"Hello, Internet Computer!\")'","title":"Steps to Complete"},{"location":"module7-icp-integration/exercises/01_hello_icp/#expected-results","text":"The canister should store a greeting message (default: \"Hello, World!\") Users should be able to update the greeting with a new message Users should be able to query the current greeting","title":"Expected Results"},{"location":"module7-icp-integration/exercises/01_hello_icp/#tips","text":"Use thread_local! to create state that persists between canister calls Remember that all update methods should modify the state through a mutable reference Test your canister locally before deploying to the IC mainnet Use the Candid UI to interact with your canister during testing For the additional challenge, consider using a Vec<String> to store the greeting history","title":"Tips"}]}